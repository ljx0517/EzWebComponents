{"version":3,"file":"ez-pop-wrapper.js","mappings":"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","sources":["webpack://ez-web-components/./src/components/ez-pop-wrapper/style.less","webpack://ez-web-components/./node_modules/css-loader/dist/runtime/api.js","webpack://ez-web-components/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://ez-web-components/./src/components/ez-pop-wrapper/index.ts","webpack://ez-web-components/webpack/bootstrap","webpack://ez-web-components/webpack/startup"],"sourcesContent":["// Imports\nvar ___CSS_LOADER_API_SOURCEMAP_IMPORT___ = require(\"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\");\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../node_modules/css-loader/dist/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".style__pop-slot {\\n  display: inline;\\n  position: relative;\\n}\\n.style__anchor {\\n  /* */\\n  position: relative;\\n  overflow: visible;\\n}\\nslot[name=pop]::slotted(*) {\\n  min-width: 112px;\\n  display: none;\\n  position: absolute;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n  max-width: calc(100vw - 32px);\\n  max-height: calc(100vh - 32px);\\n  margin: 0;\\n  padding: 0;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transform-origin: top left;\\n  -ms-transform-origin: top left;\\n  transform-origin: top left;\\n  opacity: 0;\\n  overflow: auto;\\n  will-change: transform,opacity;\\n  z-index: 8;\\n  -webkit-transition: opacity 0.03s linear, -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  transition: opacity 0.03s linear, -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  -o-transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1), -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  -webkit-box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n  background-color: #fff;\\n  background-color: var(--mdc-theme-surface, #fff);\\n  color: #000;\\n  color: var(--mdc-theme-on-surface, #000);\\n  border-radius: 4px;\\n  transform-origin-left: top left;\\n  transform-origin-right: top right;\\n}\\nslot[name=pop].style__open::slotted(*) {\\n  display: inline-block;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  opacity: 1;\\n}\\n.style__backdrop {\\n  background: #333;\\n  display: none;\\n}\\n.style__open .style__backdrop {\\n  display: block;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/ez-pop-wrapper/style.less\"],\"names\":[],\"mappings\":\"AAgBA;EACE,eAAA;EACA,kBAAA;AAfF;AAoBA;EAlBE,IAAI;EAoBJ,kBAAA;EACA,iBAAA;AAlBF;AAqBA;EACE,gBAAA;EACA,aAAA;EACA,kBAAA;EACA,8BAAA;EACA,sBAAA;EACA,6BAAA;EACA,8BAAA;EACA,SAAA;EACA,UAAA;EACA,2BAAA;EACA,uBAAA;EACA,mBAAA;EACA,kCAAA;EACA,8BAAA;EACA,0BAAA;EACA,UAAA;EACA,cAAA;EACA,8BAAA;EACA,UAAA;EACA,4FAAA;EACA,oFAAA;EACA,+EAAA;EACA,4EAAA;EACA,gIAAA;EACA,6HAAA;EACA,qHAAA;EACA,sBAAA;EACA,gDAAA;EACA,WAAA;EACA,wCAAA;EACA,kBAAA;EACA,+BAAA;EACA,iCAAA;AAnBF;AAqBA;EACE,qBAAA;EACA,2BAAA;EACA,uBAAA;EACA,mBAAA;EACA,UAAA;AAnBF;AAqBA;EACE,gBAAA;EACA,aAAA;AAnBF;AAqBA;EACE,cAAA;AAnBF\",\"sourcesContent\":[\"\\n:host{\\n\\n}\\n\\n\\n\\n//.open {\\n//  display: inline-block;\\n//  -webkit-transform: scale(1);\\n//  -ms-transform: scale(1);\\n//  transform: scale(1);\\n//  opacity: 1;\\n//}\\n\\n\\n.pop-slot{\\n  display: inline;\\n  position: relative;\\n}\\n\\n\\n\\n.anchor {\\n  /* */\\n  position: relative;\\n  overflow: visible;\\n}\\n\\nslot[name=pop]::slotted(*) {\\n  min-width: 112px;\\n  display: none;\\n  position: absolute;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n  max-width: calc(100vw - 32px);\\n  max-height: calc(100vh - 32px);\\n  margin: 0;\\n  padding: 0;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transform-origin: top left;\\n  -ms-transform-origin: top left;\\n  transform-origin: top left;\\n  opacity: 0;\\n  overflow: auto;\\n  will-change: transform,opacity;\\n  z-index: 8;\\n  -webkit-transition: opacity .03s linear,-webkit-transform .12s cubic-bezier(0,0,.2,1);\\n  transition: opacity .03s linear,-webkit-transform .12s cubic-bezier(0,0,.2,1);\\n  -o-transition: opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1);\\n  transition: opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1);\\n  transition: opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1),-webkit-transform .12s cubic-bezier(0,0,.2,1);\\n  -webkit-box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);\\n  box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);\\n  background-color: #fff;\\n  background-color: var(--mdc-theme-surface,#fff);\\n  color: #000;\\n  color: var(--mdc-theme-on-surface,#000);\\n  border-radius: 4px;\\n  transform-origin-left: top left;\\n  transform-origin-right: top right;\\n}\\nslot[name=pop].open::slotted(*) {\\n  display: inline-block;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  opacity: 1;\\n}\\n.backdrop{\\n  background: #333;\\n  display: none;\\n}\\n.open .backdrop{\\n  display: block;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"pop-slot\": \"style__pop-slot\",\n\t\"popSlot\": \"style__pop-slot\",\n\t\"anchor\": \"style__anchor\",\n\t\"open\": \"style__open\",\n\t\"backdrop\": \"style__backdrop\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","import style from \"./style.less\"\nconst stylesheet = new CSSStyleSheet();\n\n\nconst IS_OPEN_BELOW = 'is-open-below'\ninterface IDimensions {\n  height: number;\n  width: number;\n}\nconst numbers = {\n  /** Total duration of menu-surface open animation. */\n  TRANSITION_OPEN_DURATION: 120,\n\n  /** Total duration of menu-surface close animation. */\n  TRANSITION_CLOSE_DURATION: 75,\n\n  /**\n   * Margin left to the edge of the viewport when menu-surface is at maximum\n   * possible height. Also used as a viewport margin.\n   */\n  MARGIN_TO_EDGE: 32,\n\n  /**\n   * Ratio of anchor width to menu-surface width for switching from corner\n   * positioning to center positioning.\n   */\n  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,\n\n  /**\n   * Amount of time to wait before restoring focus when closing the menu\n   * surface. This is important because if a touch event triggered the menu\n   * close, and the subsequent mouse event occurs after focus is restored, then\n   * the restored focus would be lost.\n   */\n  TOUCH_EVENT_WAIT_MS: 30,\n};\n/**\n * Enum for bits in the {@see Corner) bitmap.\n */\nenum CornerBit {\n  BOTTOM = 1,\n  CENTER = 2,\n  RIGHT = 4,\n  FLIP_RTL = 8,\n}\n\n/**\n * Enum for representing an element corner for positioning the menu-surface.\n *\n * The START constants map to LEFT if element directionality is left\n * to right and RIGHT if the directionality is right to left.\n * Likewise END maps to RIGHT or LEFT depending on the directionality.\n */\nenum Corner {\n  TOP_LEFT = 0,\n  TOP_RIGHT = CornerBit.RIGHT,\n  BOTTOM_LEFT = CornerBit.BOTTOM,\n  BOTTOM_RIGHT = CornerBit.BOTTOM | CornerBit.RIGHT, // tslint:disable-line:no-bitwise\n  TOP_START = CornerBit.FLIP_RTL,\n  TOP_END = CornerBit.FLIP_RTL | CornerBit.RIGHT, // tslint:disable-line:no-bitwise\n  BOTTOM_START = CornerBit.BOTTOM | CornerBit.FLIP_RTL, // tslint:disable-line:no-bitwise\n  BOTTOM_END = CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL, // tslint:disable-line:no-bitwise\n}\ninterface IDistance {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface IPoint {\n  x: number;\n  y: number;\n}\ninterface IAutoLayoutMeasurements {\n  anchorSize: IDimensions;\n  bodySize: IDimensions;\n  surfaceSize: IDimensions;\n  viewportDistance: IDistance;\n  viewportSize: IDimensions;\n  windowScroll: IPoint;\n}\nclass EzPopWrapper extends HTMLElement {\n\n\n  private beforeCloseHooks:(() => boolean)[] = [];\n  private afterCloseHooks: (() => void)[] = [];\n  private beforeActiveTabHooks:(() => boolean)[] = [];\n  private afterActiveTabHooks: (() => void)[] = [];\n  private isSurfaceOpen: any;\n  private dimensions: IDimensions;\n  private measurements: any;\n  private isHoistedElement = false;\n  private isFixedPosition = false\n  private isHorizontallyCenteredOnViewport = false;\n  private anchor: HTMLElement;\n  private root: HTMLElement;\n  private position: IPoint;\n  private anchorCorner: Corner = Corner.TOP_START;\n  private maxHeight = 0;\n  private openBottomBias = 0;\n  private originCorner: Corner = Corner.TOP_START;\n  private readonly anchorMargin:\n    IDistance = {top: 0, right: 0, bottom: 0, left: 0};\n  // TODO isQuickOpen is not use animation\n  private isQuickOpen = true;\n  private targetItem: HTMLElement;\n  constructor() {\n    super();\n    // element created\n    const shadow = this.attachShadow({ mode: 'open' });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    shadow.adoptedStyleSheets = [stylesheet];\n    shadow.innerHTML = `\n       <slot name=\"title\" class=\"${style.anchor}\"></slot>\n       <slot name=\"pop\" tabIndex=\"-1\" class=\"${style.popSlot}\"></slot>\n    `.replace(/[\\s\\n]*\\n[\\s\\n]*/g, '');\n  }\n\n  connectedCallback() {\n    // browser calls this method when the element is added to the document\n    // (can be called many times if an element is repeatedly added/removed)\n    // Only actually parse the stylesheet when the first instance is connected.\n    if (stylesheet.cssRules.length == 0) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      stylesheet.replaceSync(style.toString());\n    }\n    // this.anchor = document.createElement('div')\n    // this.anchor.className = style.anchor\n    // this.anchor = this.shadowRoot.querySelector(`.${style.anchor}`)\n    this.anchor = this.querySelector('[slot=title]');\n    this.root = this.shadowRoot.querySelector('slot[name=pop]');\n\n    this.targetItem = (this.querySelector('[slot=pop]') as HTMLElement);\n    this.targetItem.setAttribute('tabIndex', '-1')\n\n    this.root.addEventListener('click', (e) => {\n      e.stopPropagation();\n    });\n    this.anchor.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      this.open();\n    });\n    /*console.log(this.targetItem)\n    this.targetItem.addEventListener('blur', (e) => {\n      console.log('blur', e.target)\n      let t = e.target as HTMLElement\n      while (t != this.targetItem) {\n        t = t.parentElement;\n        if ( t == document.body ) {\n          break\n        }\n        if ( t == this.targetItem ) {\n          this.close();\n          break\n        }\n      }\n\n      e.preventDefault();\n      e.stopPropagation()\n    }) */\n    document.addEventListener('click', (e) => {\n      this.close();\n      e.preventDefault();\n      e.stopPropagation()\n    })\n\n    const backdrop = document.createElement('div');\n    // backdrop.setAttribute('slot', 'pop')\n    backdrop.className = style.backdrop\n    backdrop.style.cssText = ``.replace(/[\\s\\n]*\\n[\\s\\n]*/g, '');\n    this.root.appendChild(backdrop);\n  }\n\n  open() {\n    if (this.isSurfaceOpen) {\n      return;\n    }\n    if (this.isQuickOpen) {\n      this.isSurfaceOpen = true;\n      this.root.classList.add(style.open);\n      this.dimensions = this.getInnerDimensions();\n      this.autoPosition();\n      const target = (this.querySelector('[slot=pop]') as HTMLElement)\n      // target.setAttribute('tabIndex', '-1')\n      // target.focus({preventScroll: true})\n      // this.notifyOpen();\n    }\n\n  }\n  close(skipRestoreFocus = false) {\n    if (!this.isSurfaceOpen) {\n      return;\n    }\n    // if (this.isQuickOpen) {\n      this.isSurfaceOpen = false;\n      this.root.classList.remove(style.open);\n      this.anchor.classList.remove(IS_OPEN_BELOW);\n      // notifyClosing;\n    // }\n\n\n  }\n\n\n  getInnerDimensions() :IDimensions{\n    return { width:this.anchor.offsetWidth, height: this.anchor.offsetHeight };\n  }\n  private hasBit(corner: Corner, bit: CornerBit): boolean {\n    return Boolean(corner & bit);  // tslint:disable-line:no-bitwise\n  }\n\n  private setBit(corner: Corner, bit: CornerBit): Corner {\n    return corner | bit;  // tslint:disable-line:no-bitwise\n  }\n\n  private unsetBit(corner: Corner, bit: CornerBit): Corner {\n    return corner ^ bit;\n  }\n\n  private autoPosition() {\n\n    this.measurements = this.getAutoLayoutMeasurements();\n    const corner = this.getOriginCorner();\n    const maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);\n    const verticalAlignment =\n      this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n    let horizontalAlignment =\n      this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';\n    const horizontalOffset = this.getHorizontalOriginOffset(corner);\n    const verticalOffset = this.getVerticalOriginOffset(corner);\n    const {anchorSize, surfaceSize} = this.measurements;\n\n    const position: Partial<IDistance> = {\n      [horizontalAlignment]: horizontalOffset,\n      [verticalAlignment]: verticalOffset,\n    };\n\n    // Center align when anchor width is comparable or greater than menu\n    // surface, otherwise keep corner.\n    if (anchorSize.width / surfaceSize.width >\n      numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n      horizontalAlignment = 'center';\n    }\n\n    // If the menu-surface has been hoisted to the body, it's no longer relative\n    // to the anchor element\n    if (this.isHoistedElement || this.isFixedPosition) {\n      this.adjustPositionForHoistedElement(position);\n    }\n\n    this.setTransformOrigin(\n      `${horizontalAlignment} ${verticalAlignment}`);\n    this.setPosition(position);\n    this.setMaxHeight(\n      maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\n\n    // If it is opened from the top then add is-open-below class\n    if (!this.hasBit(corner, CornerBit.BOTTOM)) {\n      this.anchor.classList.add(IS_OPEN_BELOW);\n    }\n  }\n  setPosition (position:  Partial<IDistance>) {\n    const rootHTML = this.targetItem as HTMLElement;\n    rootHTML.style.left = 'left' in position ? `${position.left}px` : '';\n    rootHTML.style.right = 'right' in position ? `${position.right}px` : '';\n    rootHTML.style.top = 'top' in position ? `${position.top}px` : '';\n    rootHTML.style.bottom = 'bottom' in position ? `${position.bottom}px` : '';\n  }\n  setMaxHeight(height: string) {\n    (this.targetItem as HTMLElement).style.maxHeight = height;\n  }\n  setTransformOrigin (origin: string) {\n    const propertyName = `transform-origin`;\n     // (this.root as HTMLElement).style.setProperty(propertyName, origin);\n     (this.targetItem as HTMLElement).style.setProperty(propertyName, origin);\n  }\n  /**\n   * Calculates the offsets for positioning the menu-surface when the\n   * menu-surface has been hoisted to the body.\n   */\n  private adjustPositionForHoistedElement(position: Partial<IDistance>) {\n    const {windowScroll, viewportDistance, surfaceSize, viewportSize} =\n      this.measurements;\n\n    const props =\n      Object.keys(position) as Array<keyof Partial<IDistance>>;\n\n    for (const prop of props) {\n      let value = position[prop] || 0;\n\n      if (this.isHorizontallyCenteredOnViewport &&\n        (prop === 'left' || prop === 'right')) {\n        position[prop] = (viewportSize.width - surfaceSize.width) / 2;\n        continue;\n      }\n\n      // Hoisted surfaces need to have the anchor elements location on the page\n      // added to the position properties for proper alignment on the body.\n      value += viewportDistance[prop];\n\n      // Surfaces that are absolutely positioned need to have additional\n      // calculations for scroll and bottom positioning.\n      if (!this.isFixedPosition) {\n        if (prop === 'top') {\n          value += windowScroll.y;\n        } else if (prop === 'bottom') {\n          value -= windowScroll.y;\n        } else if (prop === 'left') {\n          value += windowScroll.x;\n        } else {  // prop === 'right'\n          value -= windowScroll.x;\n        }\n      }\n\n      position[prop] = value;\n    }\n  }\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Vertical offset of menu surface origin corner from corresponding\n   *     anchor corner.\n   */\n  private getVerticalOriginOffset(corner: Corner): number {\n    const {anchorSize} = this.measurements;\n    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n    const avoidVerticalOverlap =\n      this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n\n    let y = 0;\n    if (isBottomAligned) {\n      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top :\n        -this.anchorMargin.bottom;\n    } else {\n      y = avoidVerticalOverlap ?\n        (anchorSize.height + this.anchorMargin.bottom) :\n        this.anchorMargin.top;\n    }\n    return y;\n  }\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Horizontal offset of menu surface origin corner from corresponding\n   *     anchor corner.\n   */\n  private getHorizontalOriginOffset(corner: Corner): number {\n    const {anchorSize} = this.measurements;\n\n    // isRightAligned corresponds to using the 'right' property on the surface.\n    const isRightAligned = this.hasBit(corner, CornerBit.RIGHT);\n    const avoidHorizontalOverlap =\n      this.hasBit(this.anchorCorner, CornerBit.RIGHT);\n\n    if (isRightAligned) {\n      const rightOffset = avoidHorizontalOverlap ?\n        anchorSize.width - this.anchorMargin.left :\n        this.anchorMargin.right;\n\n      // For hoisted or fixed elements, adjust the offset by the difference\n      // between viewport width and body width so when we calculate the right\n      // value (`adjustPositionForHoistedElement`) based on the element\n      // position, the right property is correct.\n      if (this.isHoistedElement || this.isFixedPosition) {\n        return rightOffset -\n          (this.measurements.viewportSize.width -\n            this.measurements.bodySize.width);\n      }\n\n      return rightOffset;\n    }\n\n    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right :\n      this.anchorMargin.left;\n  }\n  private getAnchorDimensions() {\n    return this.anchor.getBoundingClientRect();\n  }\n  private getBodyDimensions(): IDimensions { return  { width: document.body.clientWidth, height: document.body.clientHeight }; }\n  private getWindowDimensions(): IDimensions {\n    return { width: window.innerWidth, height: window.innerHeight };\n  }\n  getWindowScroll () {\n    // return { x: window.pageXOffset, y: window.pageYOffset };\n    return { x: window.scrollX, y: window.scrollY};\n  }\n  private getAutoLayoutMeasurements() {\n    let anchorRect = this.getAnchorDimensions();\n    const bodySize = this.getBodyDimensions();\n    const viewportSize = this.getWindowDimensions();\n    const windowScroll = this.getWindowScroll();\n\n    if (!anchorRect) {\n      // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n      anchorRect = {\n        top: this.position.y,\n        right: this.position.x,\n        bottom: this.position.y,\n        left: this.position.x,\n        width: 0,\n        height: 0,\n      } as any;\n    }\n      return {\n        anchorSize: anchorRect!,\n        bodySize,\n        surfaceSize: this.dimensions,\n        viewportDistance: {\n          // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n          top: anchorRect!.top,\n          right: viewportSize.width - anchorRect!.right,\n          bottom: viewportSize.height - anchorRect!.bottom,\n          left: anchorRect!.left,\n          // tslint:enable:object-literal-sort-keys\n        },\n        viewportSize,\n        windowScroll,\n      };\n\n  }\n\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Maximum height of the menu surface, based on available space. 0\n   *     indicates should not be set.\n   */\n  private getMenuSurfaceMaxHeight(corner: Corner): number {\n    if (this.maxHeight > 0) {\n      return this.maxHeight;\n    }\n\n    const {viewportDistance} = this.measurements;\n\n    let maxHeight = 0;\n    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n    const isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n    const {MARGIN_TO_EDGE} = numbers;\n\n    // When maximum height is not specified, it is handled from CSS.\n    if (isBottomAligned) {\n      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;\n      if (!isBottomAnchored) {\n        maxHeight += this.measurements.anchorSize.height;\n      }\n    } else {\n      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom +\n        this.measurements.anchorSize.height - MARGIN_TO_EDGE;\n      if (isBottomAnchored) {\n        maxHeight -= this.measurements.anchorSize.height;\n      }\n    }\n\n    return maxHeight;\n  }\n  private setAnchorMargin(margin: Partial<IDistance>) {\n      this.anchorMargin.top = margin.top || 0;\n      this.anchorMargin.right = margin.right || 0;\n      this.anchorMargin.bottom = margin.bottom || 0;\n      this.anchorMargin.left = margin.left || 0;\n  }\n  /**\n   * Computes the corner of the anchor from which to animate and position the\n   * menu surface.\n   *\n   * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL\n   * context. E.g., menu surface will be positioned from right side on TOP_END.\n   */\n  private getOriginCorner(): Corner {\n    let corner = this.originCorner;\n\n    const {viewportDistance, anchorSize, surfaceSize} = this.measurements;\n    const {MARGIN_TO_EDGE} = numbers;\n\n    const isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n\n    let availableTop;\n    let availableBottom;\n    if (isAnchoredToBottom) {\n      availableTop =\n        viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;\n      availableBottom =\n        viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;\n    } else {\n      availableTop =\n        viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;\n      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE +\n        anchorSize.height - this.anchorMargin.top;\n    }\n\n    const isAvailableBottom = availableBottom - surfaceSize.height > 0;\n    if (!isAvailableBottom &&\n      availableTop > availableBottom + this.openBottomBias) {\n      // Attach bottom side of surface to the anchor.\n      corner = this.setBit(corner, CornerBit.BOTTOM);\n    }\n\n    const isRtl = false; //this.adapter.isRtl();\n    const isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);\n    const hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) ||\n      this.hasBit(corner, CornerBit.RIGHT);\n\n    // Whether surface attached to right side of anchor element.\n    let isAnchoredToRight = false;\n\n    // Anchored to start\n    if (isRtl && isFlipRtl) {\n      isAnchoredToRight = !hasRightBit;\n    } else {\n      // Anchored to right\n      isAnchoredToRight = hasRightBit;\n    }\n\n\n    let availableLeft;\n    let availableRight;\n    if (isAnchoredToRight) {\n      availableLeft =\n        viewportDistance.left + anchorSize.width + this.anchorMargin.right;\n      availableRight = viewportDistance.right - this.anchorMargin.right;\n    } else {\n      availableLeft = viewportDistance.left + this.anchorMargin.left;\n      availableRight =\n        viewportDistance.right + anchorSize.width - this.anchorMargin.left;\n    }\n\n    const isAvailableLeft = availableLeft - surfaceSize.width > 0;\n    const isAvailableRight = availableRight - surfaceSize.width > 0;\n    const isOriginCornerAlignedToEnd =\n      this.hasBit(corner, CornerBit.FLIP_RTL) &&\n      this.hasBit(corner, CornerBit.RIGHT);\n\n    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl ||\n      !isAvailableLeft && isOriginCornerAlignedToEnd) {\n      // Attach left side of surface to the anchor.\n      corner = this.unsetBit(corner, CornerBit.RIGHT);\n    } else if (\n      isAvailableLeft && isAnchoredToRight && isRtl ||\n      (isAvailableLeft && !isAnchoredToRight && hasRightBit) ||\n      (!isAvailableRight && availableLeft >= availableRight)) {\n      // Attach right side of surface to the anchor.\n      corner = this.setBit(corner, CornerBit.RIGHT);\n    }\n\n    return corner;\n  }\n\n\n\n  disconnectedCallback() {\n    // browser calls this method when the element is removed from the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  static get observedAttributes(): string[]  {\n    return [/* array of attribute names to monitor for changes */];\n  }\n\n  attributeChangedCallback(name: string, oldValue: string, newValue: string) {\n    // called when one of attributes listed above is modified\n  }\n\n  adoptedCallback() {\n    // called when the element is moved to a new document\n    // (happens in document.adoptNode, very rarely used)\n  }\n\n  // there can be other element methods and properties\n}\ncustomElements.define(\"ez-pop-wrapper\", EzPopWrapper);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(636);\n"],"names":["___CSS_LOADER_API_SOURCEMAP_IMPORT___","___CSS_LOADER_EXPORT___","___CSS_LOADER_API_IMPORT___","push","module","id","locals","exports","cssWithMappingToString","list","toString","this","map","item","content","needLayer","concat","length","join","i","modules","media","dedupe","supports","layer","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","stylesheet","CSSStyleSheet","IS_OPEN_BELOW","numbers","TRANSITION_OPEN_DURATION","TRANSITION_CLOSE_DURATION","MARGIN_TO_EDGE","ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO","TOUCH_EVENT_WAIT_MS","CornerBit","Corner","EzPopWrapper","HTMLElement","constructor","super","beforeCloseHooks","afterCloseHooks","beforeActiveTabHooks","afterActiveTabHooks","isHoistedElement","isFixedPosition","isHorizontallyCenteredOnViewport","anchorCorner","TOP_START","maxHeight","openBottomBias","originCorner","anchorMargin","top","right","bottom","left","isQuickOpen","shadow","attachShadow","mode","adoptedStyleSheets","innerHTML","anchor","popSlot","replace","connectedCallback","cssRules","replaceSync","querySelector","root","shadowRoot","targetItem","setAttribute","addEventListener","e","stopPropagation","preventDefault","open","document","close","backdrop","createElement","className","style","cssText","appendChild","isSurfaceOpen","classList","add","dimensions","getInnerDimensions","autoPosition","skipRestoreFocus","remove","width","offsetWidth","height","offsetHeight","hasBit","corner","bit","Boolean","setBit","unsetBit","measurements","getAutoLayoutMeasurements","getOriginCorner","maxMenuSurfaceHeight","getMenuSurfaceMaxHeight","verticalAlignment","BOTTOM","horizontalAlignment","RIGHT","horizontalOffset","getHorizontalOriginOffset","verticalOffset","getVerticalOriginOffset","anchorSize","surfaceSize","position","adjustPositionForHoistedElement","setTransformOrigin","setPosition","setMaxHeight","rootHTML","origin","setProperty","windowScroll","viewportDistance","viewportSize","props","Object","keys","prop","value","y","x","isBottomAligned","avoidVerticalOverlap","isRightAligned","avoidHorizontalOverlap","rightOffset","bodySize","getAnchorDimensions","getBoundingClientRect","getBodyDimensions","body","clientWidth","clientHeight","getWindowDimensions","window","innerWidth","innerHeight","getWindowScroll","scrollX","scrollY","anchorRect","isBottomAnchored","setAnchorMargin","margin","availableTop","availableBottom","FLIP_RTL","hasRightBit","availableLeft","availableRight","isAnchoredToRight","isAvailableLeft","isAvailableRight","isOriginCornerAlignedToEnd","disconnectedCallback","observedAttributes","attributeChangedCallback","name","oldValue","newValue","adoptedCallback","customElements","define","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}