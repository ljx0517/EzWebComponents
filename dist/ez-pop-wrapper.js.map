{"version":3,"file":"ez-pop-wrapper.js","mappings":"2BACA,IAAIA,EAAwC,EAAQ,KAEhDC,EAD8B,EAAQ,IACZC,CAA4BF,GAE1DC,EAAwBE,KAAK,CAACC,EAAOC,GAAI,m8DAAo8D,GAAG,CAAC,QAAU,EAAE,QAAU,CAAC,iEAAiE,MAAQ,GAAG,SAAW,yjBAAyjB,eAAiB,CAAC,k9DAAk9D,WAAa,MAEzoJJ,EAAwBK,OAAS,CAChC,WAAY,2BACZ,QAAW,2BACX,OAAU,yBACV,KAAQ,uBACR,SAAY,4BAMVL,EAA0B,IAAIM,MAAMN,EAAyB,CACxDO,IAAK,SAASC,EAAQC,EAAMC,GAE1B,OAAID,KAAQD,EACFA,EAAOC,GAEbD,EAAOH,QAAUI,KAAQD,EAAOH,OAC3BG,EAAOH,OAAOI,GAEhBE,QAAQJ,OAAOK,cAG7BT,EAAOU,QAAUb,G,qBCxBpBG,EAAOU,QAAU,SAAUC,GACzB,IAAIC,EAAO,GA6FX,OA3FAA,EAAKC,SAAW,WACd,OAAOC,KAAKC,KAAI,SAAUC,GACxB,IAAIC,EAAU,GACVC,OAA+B,IAAZF,EAAK,GA4B5B,OA1BIA,EAAK,KACPC,GAAW,cAAcE,OAAOH,EAAK,GAAI,QAGvCA,EAAK,KACPC,GAAW,UAAUE,OAAOH,EAAK,GAAI,OAGnCE,IACFD,GAAW,SAASE,OAAOH,EAAK,GAAGI,OAAS,EAAI,IAAID,OAAOH,EAAK,IAAM,GAAI,OAG5EC,GAAWN,EAAuBK,GAE9BE,IACFD,GAAW,KAGTD,EAAK,KACPC,GAAW,KAGTD,EAAK,KACPC,GAAW,KAGNA,KACNI,KAAK,KAIVT,EAAKU,EAAI,SAAWC,EAASC,EAAOC,EAAQC,EAAUC,GAC7B,iBAAZJ,IACTA,EAAU,CAAC,CAAC,KAAMA,OAASK,KAG7B,IAAIC,EAAyB,GAE7B,GAAIJ,EACF,IAAK,IAAIK,EAAI,EAAGA,EAAIhB,KAAKM,OAAQU,IAAK,CACpC,IAAI7B,EAAKa,KAAKgB,GAAG,GAEP,MAAN7B,IACF4B,EAAuB5B,IAAM,GAKnC,IAAK,IAAI8B,EAAK,EAAGA,EAAKR,EAAQH,OAAQW,IAAM,CAC1C,IAAIf,EAAO,GAAGG,OAAOI,EAAQQ,IAEzBN,GAAUI,EAAuBb,EAAK,WAIrB,IAAVW,SACc,IAAZX,EAAK,KAGdA,EAAK,GAAK,SAASG,OAAOH,EAAK,GAAGI,OAAS,EAAI,IAAID,OAAOH,EAAK,IAAM,GAAI,MAAMG,OAAOH,EAAK,GAAI,MAF/FA,EAAK,GAAKW,GAOVH,IACGR,EAAK,IAGRA,EAAK,GAAK,UAAUG,OAAOH,EAAK,GAAI,MAAMG,OAAOH,EAAK,GAAI,KAC1DA,EAAK,GAAKQ,GAHVR,EAAK,GAAKQ,GAOVE,IACGV,EAAK,IAGRA,EAAK,GAAK,cAAcG,OAAOH,EAAK,GAAI,OAAOG,OAAOH,EAAK,GAAI,KAC/DA,EAAK,GAAKU,GAHVV,EAAK,GAAK,GAAGG,OAAOO,IAOxBd,EAAKb,KAAKiB,MAIPJ,I,qBClGTZ,EAAOU,QAAU,SAAUM,GACzB,IAAIC,EAAUD,EAAK,GACfgB,EAAahB,EAAK,GAEtB,IAAKgB,EACH,OAAOf,EAGT,GAAoB,mBAATgB,KAAqB,CAC9B,IAAIC,EAASD,KAAKE,SAASC,mBAAmBC,KAAKC,UAAUN,MACzDO,EAAO,+DAA+DpB,OAAOe,GAC7EM,EAAgB,OAAOrB,OAAOoB,EAAM,OACpCE,EAAaT,EAAWU,QAAQ3B,KAAI,SAAU4B,GAChD,MAAO,iBAAiBxB,OAAOa,EAAWY,YAAc,IAAIzB,OAAOwB,EAAQ,UAE7E,MAAO,CAAC1B,GAASE,OAAOsB,GAAYtB,OAAO,CAACqB,IAAgBnB,KAAK,MAGnE,MAAO,CAACJ,GAASI,KAAK,SCnBpBwB,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBnB,IAAjBoB,EACH,OAAOA,EAAatC,QAGrB,IAAIV,EAAS6C,EAAyBE,GAAY,CACjD9C,GAAI8C,EAEJrC,QAAS,IAOV,OAHAuC,EAAoBF,GAAU/C,EAAQA,EAAOU,QAASoC,GAG/C9C,EAAOU,Q,mBCrBf,eACMwC,EAAa,IAAIC,cAGjBC,EAAgB,gBAKhBC,EAAU,CAEdC,yBAA0B,IAG1BC,0BAA2B,GAM3BC,eAAgB,GAMhBC,mCAAoC,IAQpCC,oBAAqB,IAKvB,IAAKC,EAcAC,GAdL,SAAKD,GACH,uBACA,uBACA,qBACA,2BAJF,CAAKA,IAAAA,EAAS,KAcd,SAAKC,GACH,2BACA,6BACA,iCACA,mCACA,6BACA,0BACA,mCACA,gCARF,CAAKA,IAAAA,EAAM,KA6BX,MAAMC,UAAqBC,YAyBzBC,cACEC,QAvBM,KAAAC,iBAAqC,GACrC,KAAAC,gBAAkC,GAClC,KAAAC,qBAAyC,GACzC,KAAAC,oBAAsC,GAItC,KAAAC,kBAAmB,EACnB,KAAAC,iBAAkB,EAClB,KAAAC,kCAAmC,EAInC,KAAAC,aAAuBZ,EAAOa,UAC9B,KAAAC,UAAY,EACZ,KAAAC,eAAiB,EACjB,KAAAC,aAAuBhB,EAAOa,UACrB,KAAAI,aACH,CAACC,IAAK,EAAGC,MAAO,EAAGC,OAAQ,EAAGC,KAAM,GAE1C,KAAAC,aAAc,EAKpB,MAAMC,EAASrE,KAAKsE,aAAa,CAAEC,KAAM,SAGzCF,EAAOG,mBAAqB,CAACpC,GAC7BiC,EAAOI,UAAY,sCACYC,EAAMC,iEACMD,EAAME,yBAC/CC,QAAQ,oBAAqB,IAGjCC,oBAIoC,GAA9B1C,EAAW2C,SAASzE,QAGtB8B,EAAW4C,YAAYN,EAAM3E,YAK/BC,KAAK2E,OAAS3E,KAAKiF,cAAc,gBACjCjF,KAAKkF,KAAOlF,KAAKmF,WAAWF,cAAc,kBAE1CjF,KAAKoF,WAAcpF,KAAKiF,cAAc,cACtCjF,KAAKoF,WAAWC,aAAa,WAAY,MAEzCrF,KAAKkF,KAAKI,iBAAiB,SAAUC,IACnCA,EAAEC,qBAEJxF,KAAK2E,OAAOW,iBAAiB,SAAUC,IACrCA,EAAEE,iBACFF,EAAEC,kBACFxF,KAAK0F,UAoBPC,SAASL,iBAAiB,SAAUC,IAClCvF,KAAK4F,QACLL,EAAEE,iBACFF,EAAEC,qBAGJ,MAAMK,EAAWF,SAASG,cAAc,OAExCD,EAASE,UAAYrB,EAAMmB,SAC3BA,EAASnB,MAAMsB,QAAU,GAAGnB,QAAQ,oBAAqB,IACzD7E,KAAKkF,KAAKe,YAAYJ,GAGxBH,QACM1F,KAAKkG,eAGLlG,KAAKoE,cACPpE,KAAKkG,eAAgB,EACrBlG,KAAKkF,KAAKiB,UAAUC,IAAI1B,EAAMgB,MAC9B1F,KAAKqG,WAAarG,KAAKsG,qBACvBtG,KAAKuG,eACWvG,KAAKiF,cAAc,eAOvCW,MAAMY,GAAmB,GAClBxG,KAAKkG,gBAIRlG,KAAKkG,eAAgB,EACrBlG,KAAKkF,KAAKiB,UAAUM,OAAO/B,EAAMgB,MACjC1F,KAAK2E,OAAOwB,UAAUM,OAAOnE,IAQjCgE,qBACE,MAAO,CAAEI,MAAM1G,KAAK2E,OAAOgC,YAAaC,OAAQ5G,KAAK2E,OAAOkC,cAEtDC,OAAOC,EAAgBC,GAC7B,OAAOC,QAAQF,EAASC,GAGlBE,OAAOH,EAAgBC,GAC7B,OAAOD,EAASC,EAGVG,SAASJ,EAAgBC,GAC/B,OAAOD,EAASC,EAGVT,eAENvG,KAAKoH,aAAepH,KAAKqH,4BACzB,MAAMN,EAAS/G,KAAKsH,kBACdC,EAAuBvH,KAAKwH,wBAAwBT,GACpDU,EACJzH,KAAK8G,OAAOC,EAAQlE,EAAU6E,QAAU,SAAW,MACrD,IAAIC,EACF3H,KAAK8G,OAAOC,EAAQlE,EAAU+E,OAAS,QAAU,OACnD,MAAMC,EAAmB7H,KAAK8H,0BAA0Bf,GAClDgB,EAAiB/H,KAAKgI,wBAAwBjB,IAC9C,WAACkB,EAAU,YAAEC,GAAelI,KAAKoH,aAEjCe,EAA+B,CACnC,CAACR,GAAsBE,EACvB,CAACJ,GAAoBM,GAKnBE,EAAWvB,MAAQwB,EAAYxB,MACjCnE,EAAQI,qCACRgF,EAAsB,WAKpB3H,KAAKuD,kBAAoBvD,KAAKwD,kBAChCxD,KAAKoI,gCAAgCD,GAGvCnI,KAAKqI,mBACH,GAAGV,KAAuBF,KAC5BzH,KAAKsI,YAAYH,GACjBnI,KAAKuI,aACHhB,EAAuBA,EAAuB,KAAO,IAGlDvH,KAAK8G,OAAOC,EAAQlE,EAAU6E,SACjC1H,KAAK2E,OAAOwB,UAAUC,IAAI9D,GAG9BgG,YAAaH,GACX,MAAMK,EAAWxI,KAAKoF,WACtBoD,EAAS9D,MAAMP,KAAO,SAAUgE,EAAW,GAAGA,EAAShE,SAAW,GAClEqE,EAAS9D,MAAMT,MAAQ,UAAWkE,EAAW,GAAGA,EAASlE,UAAY,GACrEuE,EAAS9D,MAAMV,IAAM,QAASmE,EAAW,GAAGA,EAASnE,QAAU,GAC/DwE,EAAS9D,MAAMR,OAAS,WAAYiE,EAAW,GAAGA,EAASjE,WAAa,GAE1EqE,aAAa3B,GACV5G,KAAKoF,WAA2BV,MAAMd,UAAYgD,EAErDyB,mBAAoBI,GAGhBzI,KAAKoF,WAA2BV,MAAMgE,YAFnB,mBAE6CD,GAM5DL,gCAAgCD,GACtC,MAAM,aAACQ,EAAY,iBAAEC,EAAgB,YAAEV,EAAW,aAAEW,GAClD7I,KAAKoH,aAED0B,EACJC,OAAOC,KAAKb,GAEd,IAAK,MAAM3I,KAAQsJ,EAAO,CACxB,IAAIG,EAAQd,EAAS3I,IAAS,GAE1BQ,KAAKyD,kCACG,SAATjE,GAA4B,UAATA,GAOtByJ,GAASL,EAAiBpJ,GAIrBQ,KAAKwD,kBACK,QAAThE,EACFyJ,GAASN,EAAaO,EACJ,WAAT1J,EACTyJ,GAASN,EAAaO,EACJ,SAAT1J,EACTyJ,GAASN,EAAaQ,EAEtBF,GAASN,EAAaQ,GAI1BhB,EAAS3I,GAAQyJ,GAtBfd,EAAS3I,IAASqJ,EAAanC,MAAQwB,EAAYxB,OAAS,GA8B1DsB,wBAAwBjB,GAC9B,MAAM,WAACkB,GAAcjI,KAAKoH,aACpBgC,EAAkBpJ,KAAK8G,OAAOC,EAAQlE,EAAU6E,QAChD2B,EACJrJ,KAAK8G,OAAO9G,KAAK0D,aAAcb,EAAU6E,QAE3C,IAAIwB,EAAI,EASR,OAPEA,EADEE,EACEC,EAAuBpB,EAAWrB,OAAS5G,KAAK+D,aAAaC,KAC9DhE,KAAK+D,aAAaG,OAEjBmF,EACDpB,EAAWrB,OAAS5G,KAAK+D,aAAaG,OACvClE,KAAK+D,aAAaC,IAEfkF,EAODpB,0BAA0Bf,GAChC,MAAM,WAACkB,GAAcjI,KAAKoH,aAGpBkC,EAAiBtJ,KAAK8G,OAAOC,EAAQlE,EAAU+E,OAC/C2B,EACJvJ,KAAK8G,OAAO9G,KAAK0D,aAAcb,EAAU+E,OAE3C,GAAI0B,EAAgB,CAClB,MAAME,EAAcD,EAClBtB,EAAWvB,MAAQ1G,KAAK+D,aAAaI,KACrCnE,KAAK+D,aAAaE,MAMpB,OAAIjE,KAAKuD,kBAAoBvD,KAAKwD,gBACzBgG,GACJxJ,KAAKoH,aAAayB,aAAanC,MAC9B1G,KAAKoH,aAAaqC,SAAS/C,OAG1B8C,EAGT,OAAOD,EAAyBtB,EAAWvB,MAAQ1G,KAAK+D,aAAaE,MACnEjE,KAAK+D,aAAaI,KAEduF,sBACN,OAAO1J,KAAK2E,OAAOgF,wBAEbC,oBAAmC,MAAQ,CAAElD,MAAOf,SAASkE,KAAKC,YAAalD,OAAQjB,SAASkE,KAAKE,cACrGC,sBACN,MAAO,CAAEtD,MAAOuD,OAAOC,WAAYtD,OAAQqD,OAAOE,aAEpDC,kBAEE,MAAO,CAAEjB,EAAGc,OAAOI,QAASnB,EAAGe,OAAOK,SAEhCjD,4BACN,IAAIkD,EAAavK,KAAK0J,sBACtB,MAAMD,EAAWzJ,KAAK4J,oBAChBf,EAAe7I,KAAKgK,sBACpBrB,EAAe3I,KAAKoK,kBAaxB,OAXGG,IAEHA,EAAa,CACXvG,IAAKhE,KAAKmI,SAASe,EACnBjF,MAAOjE,KAAKmI,SAASgB,EACrBjF,OAAQlE,KAAKmI,SAASe,EACtB/E,KAAMnE,KAAKmI,SAASgB,EACpBzC,MAAO,EACPE,OAAQ,IAGH,CACLqB,WAAYsC,EACZd,SAAAA,EACAvB,YAAalI,KAAKqG,WAClBuC,iBAAkB,CAEhB5E,IAAKuG,EAAYvG,IACjBC,MAAO4E,EAAanC,MAAQ6D,EAAYtG,MACxCC,OAAQ2E,EAAajC,OAAS2D,EAAYrG,OAC1CC,KAAMoG,EAAYpG,MAGpB0E,aAAAA,EACAF,aAAAA,GAUEnB,wBAAwBT,GAC9B,GAAI/G,KAAK4D,UAAY,EACnB,OAAO5D,KAAK4D,UAGd,MAAM,iBAACgF,GAAoB5I,KAAKoH,aAEhC,IAAIxD,EAAY,EAChB,MAAMwF,EAAkBpJ,KAAK8G,OAAOC,EAAQlE,EAAU6E,QAChD8C,EAAmBxK,KAAK8G,OAAO9G,KAAK0D,aAAcb,EAAU6E,SAC5D,eAAChF,GAAkBH,EAgBzB,OAbI6G,GACFxF,EAAYgF,EAAiB5E,IAAMhE,KAAK+D,aAAaC,IAAMtB,EACtD8H,IACH5G,GAAa5D,KAAKoH,aAAaa,WAAWrB,UAG5ChD,EAAYgF,EAAiB1E,OAASlE,KAAK+D,aAAaG,OACtDlE,KAAKoH,aAAaa,WAAWrB,OAASlE,EACpC8H,IACF5G,GAAa5D,KAAKoH,aAAaa,WAAWrB,SAIvChD,EAED6G,gBAAgBC,GACpB1K,KAAK+D,aAAaC,IAAM0G,EAAO1G,KAAO,EACtChE,KAAK+D,aAAaE,MAAQyG,EAAOzG,OAAS,EAC1CjE,KAAK+D,aAAaG,OAASwG,EAAOxG,QAAU,EAC5ClE,KAAK+D,aAAaI,KAAOuG,EAAOvG,MAAQ,EASpCmD,kBACN,IAAIP,EAAS/G,KAAK8D,aAElB,MAAM,iBAAC8E,EAAgB,WAAEX,EAAU,YAAEC,GAAelI,KAAKoH,cACnD,eAAC1E,GAAkBH,EAIzB,IAAIoI,EACAC,EAHuB5K,KAAK8G,OAAO9G,KAAK0D,aAAcb,EAAU6E,SAKlEiD,EACE/B,EAAiB5E,IAAMtB,EAAiB1C,KAAK+D,aAAaG,OAC5D0G,EACEhC,EAAiB1E,OAASxB,EAAiB1C,KAAK+D,aAAaG,SAE/DyG,EACE/B,EAAiB5E,IAAMtB,EAAiB1C,KAAK+D,aAAaC,IAC5D4G,EAAkBhC,EAAiB1E,OAASxB,EAC1CuF,EAAWrB,OAAS5G,KAAK+D,aAAaC,OAGhB4G,EAAkB1C,EAAYtB,OAAS,IAE/D+D,EAAeC,EAAkB5K,KAAK6D,iBAEtCkD,EAAS/G,KAAKkH,OAAOH,EAAQlE,EAAU6E,SAIvB1H,KAAK8G,OAAO9G,KAAK0D,aAAcb,EAAUgI,UAD3D,MAEMC,EAAc9K,KAAK8G,OAAO9G,KAAK0D,aAAcb,EAAU+E,QAC3D5H,KAAK8G,OAAOC,EAAQlE,EAAU+E,OAGhC,IAWImD,EACAC,EAZAC,GAAoB,EAOtBA,EAAoBH,EAMlBG,GACFF,EACEnC,EAAiBzE,KAAO8D,EAAWvB,MAAQ1G,KAAK+D,aAAaE,MAC/D+G,EAAiBpC,EAAiB3E,MAAQjE,KAAK+D,aAAaE,QAE5D8G,EAAgBnC,EAAiBzE,KAAOnE,KAAK+D,aAAaI,KAC1D6G,EACEpC,EAAiB3E,MAAQgE,EAAWvB,MAAQ1G,KAAK+D,aAAaI,MAGlE,MAAM+G,EAAkBH,EAAgB7C,EAAYxB,MAAQ,EACtDyE,EAAmBH,EAAiB9C,EAAYxB,MAAQ,EACxD0E,EACJpL,KAAK8G,OAAOC,EAAQlE,EAAUgI,WAC9B7K,KAAK8G,OAAOC,EAAQlE,EAAU+E,OAchC,OAXGsD,GAAmBE,EAEpBrE,EAAS/G,KAAKmH,SAASJ,EAAQlE,EAAU+E,QAGxCsD,IAAoBD,GAAqBH,IACxCK,GAAoBJ,GAAiBC,KAEvCjE,EAAS/G,KAAKkH,OAAOH,EAAQlE,EAAU+E,QAGlCb,EAKTsE,wBAKWC,gCACT,MAAO,GAGTC,yBAAyBC,EAAcC,EAAkBC,IAIzDC,oBAOFC,eAAeC,OAAO,iBAAkB9I,I","sources":["webpack://ez-web-components/./src/components/ez-pop-wrapper/ez-pop-wrapper.less","webpack://ez-web-components/./node_modules/css-loader/dist/runtime/api.js","webpack://ez-web-components/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://ez-web-components/webpack/bootstrap","webpack://ez-web-components/./src/components/ez-pop-wrapper/ez-pop-wrapper.ts"],"sourcesContent":["// Imports\nvar ___CSS_LOADER_API_SOURCEMAP_IMPORT___ = require(\"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\");\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../node_modules/css-loader/dist/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".ez-pop-wrapper__pop-slot {\\n  display: inline;\\n  position: relative;\\n}\\n.ez-pop-wrapper__anchor {\\n  /* */\\n  position: relative;\\n  overflow: visible;\\n}\\nslot[name=pop]::slotted(*) {\\n  min-width: 112px;\\n  display: none;\\n  position: absolute;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n  max-width: calc(100vw - 32px);\\n  max-height: calc(100vh - 32px);\\n  margin: 0;\\n  padding: 0;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transform-origin: top left;\\n  -ms-transform-origin: top left;\\n  transform-origin: top left;\\n  opacity: 0;\\n  overflow: auto;\\n  will-change: transform,opacity;\\n  z-index: 8;\\n  -webkit-transition: opacity 0.03s linear, -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  transition: opacity 0.03s linear, -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  -o-transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  transition: opacity 0.03s linear, transform 0.12s cubic-bezier(0, 0, 0.2, 1), -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\\n  -webkit-box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n  background-color: #fff;\\n  background-color: var(--mdc-theme-surface, #fff);\\n  color: #000;\\n  color: var(--mdc-theme-on-surface, #000);\\n  border-radius: 4px;\\n  transform-origin-left: top left;\\n  transform-origin-right: top right;\\n}\\nslot[name=pop].ez-pop-wrapper__open::slotted(*) {\\n  display: inline-block;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  opacity: 1;\\n}\\n.ez-pop-wrapper__backdrop {\\n  background: #333;\\n  display: none;\\n}\\n.ez-pop-wrapper__open .ez-pop-wrapper__backdrop {\\n  display: block;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/ez-pop-wrapper/ez-pop-wrapper.less\"],\"names\":[],\"mappings\":\"AAgBA;EACE,eAAA;EACA,kBAAA;AAfF;AAoBA;EAlBE,IAAI;EAoBJ,kBAAA;EACA,iBAAA;AAlBF;AAqBA;EACE,gBAAA;EACA,aAAA;EACA,kBAAA;EACA,8BAAA;EACA,sBAAA;EACA,6BAAA;EACA,8BAAA;EACA,SAAA;EACA,UAAA;EACA,2BAAA;EACA,uBAAA;EACA,mBAAA;EACA,kCAAA;EACA,8BAAA;EACA,0BAAA;EACA,UAAA;EACA,cAAA;EACA,8BAAA;EACA,UAAA;EACA,4FAAA;EACA,oFAAA;EACA,+EAAA;EACA,4EAAA;EACA,gIAAA;EACA,6HAAA;EACA,qHAAA;EACA,sBAAA;EACA,gDAAA;EACA,WAAA;EACA,wCAAA;EACA,kBAAA;EACA,+BAAA;EACA,iCAAA;AAnBF;AAqBA;EACE,qBAAA;EACA,2BAAA;EACA,uBAAA;EACA,mBAAA;EACA,UAAA;AAnBF;AAqBA;EACE,gBAAA;EACA,aAAA;AAnBF;AAqBA;EACE,cAAA;AAnBF\",\"sourcesContent\":[\"\\n:host{\\n\\n}\\n\\n\\n\\n//.open {\\n//  display: inline-block;\\n//  -webkit-transform: scale(1);\\n//  -ms-transform: scale(1);\\n//  transform: scale(1);\\n//  opacity: 1;\\n//}\\n\\n\\n.pop-slot{\\n  display: inline;\\n  position: relative;\\n}\\n\\n\\n\\n.anchor {\\n  /* */\\n  position: relative;\\n  overflow: visible;\\n}\\n\\nslot[name=pop]::slotted(*) {\\n  min-width: 112px;\\n  display: none;\\n  position: absolute;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n  max-width: calc(100vw - 32px);\\n  max-height: calc(100vh - 32px);\\n  margin: 0;\\n  padding: 0;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transform-origin: top left;\\n  -ms-transform-origin: top left;\\n  transform-origin: top left;\\n  opacity: 0;\\n  overflow: auto;\\n  will-change: transform,opacity;\\n  z-index: 8;\\n  -webkit-transition: opacity .03s linear,-webkit-transform .12s cubic-bezier(0,0,.2,1);\\n  transition: opacity .03s linear,-webkit-transform .12s cubic-bezier(0,0,.2,1);\\n  -o-transition: opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1);\\n  transition: opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1);\\n  transition: opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1),-webkit-transform .12s cubic-bezier(0,0,.2,1);\\n  -webkit-box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);\\n  box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);\\n  background-color: #fff;\\n  background-color: var(--mdc-theme-surface,#fff);\\n  color: #000;\\n  color: var(--mdc-theme-on-surface,#000);\\n  border-radius: 4px;\\n  transform-origin-left: top left;\\n  transform-origin-right: top right;\\n}\\nslot[name=pop].open::slotted(*) {\\n  display: inline-block;\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  transform: scale(1);\\n  opacity: 1;\\n}\\n.backdrop{\\n  background: #333;\\n  display: none;\\n}\\n.open .backdrop{\\n  display: block;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"pop-slot\": \"ez-pop-wrapper__pop-slot\",\n\t\"popSlot\": \"ez-pop-wrapper__pop-slot\",\n\t\"anchor\": \"ez-pop-wrapper__anchor\",\n\t\"open\": \"ez-pop-wrapper__open\",\n\t\"backdrop\": \"ez-pop-wrapper__backdrop\"\n};\n\n// if(!module.i || !module.i.endsWith(\".module.less\")){\n   // return module.exports = exports;\n// } else {\n   ___CSS_LOADER_EXPORT___ = new Proxy(___CSS_LOADER_EXPORT___, {\n        get: function(target, prop, receiver) {\n          // console.log(prop, target);\n          if (prop in target) {\n             return target[prop];\n          }\n          if (target.locals && prop in target.locals) {\n            return target.locals[prop];    \n          }\n          return Reflect.get(...arguments);;\n        },\n   });\n   module.exports = ___CSS_LOADER_EXPORT___;\n// }\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as style from \"./ez-pop-wrapper.less\"\r\nconst stylesheet = new CSSStyleSheet();\r\n\r\n\r\nconst IS_OPEN_BELOW = 'is-open-below'\r\ninterface IDimensions {\r\n  height: number;\r\n  width: number;\r\n}\r\nconst numbers = {\r\n  /** Total duration of menu-surface open animation. */\r\n  TRANSITION_OPEN_DURATION: 120,\r\n\r\n  /** Total duration of menu-surface close animation. */\r\n  TRANSITION_CLOSE_DURATION: 75,\r\n\r\n  /**\r\n   * Margin left to the edge of the viewport when menu-surface is at maximum\r\n   * possible height. Also used as a viewport margin.\r\n   */\r\n  MARGIN_TO_EDGE: 32,\r\n\r\n  /**\r\n   * Ratio of anchor width to menu-surface width for switching from corner\r\n   * positioning to center positioning.\r\n   */\r\n  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,\r\n\r\n  /**\r\n   * Amount of time to wait before restoring focus when closing the menu\r\n   * surface. This is important because if a touch event triggered the menu\r\n   * close, and the subsequent mouse event occurs after focus is restored, then\r\n   * the restored focus would be lost.\r\n   */\r\n  TOUCH_EVENT_WAIT_MS: 30,\r\n};\r\n/**\r\n * Enum for bits in the {@see Corner) bitmap.\r\n */\r\nenum CornerBit {\r\n  BOTTOM = 1,\r\n  CENTER = 2,\r\n  RIGHT = 4,\r\n  FLIP_RTL = 8,\r\n}\r\n\r\n/**\r\n * Enum for representing an element corner for positioning the menu-surface.\r\n *\r\n * The START constants map to LEFT if element directionality is left\r\n * to right and RIGHT if the directionality is right to left.\r\n * Likewise END maps to RIGHT or LEFT depending on the directionality.\r\n */\r\nenum Corner {\r\n  TOP_LEFT = 0,\r\n  TOP_RIGHT = CornerBit.RIGHT,\r\n  BOTTOM_LEFT = CornerBit.BOTTOM,\r\n  BOTTOM_RIGHT = CornerBit.BOTTOM | CornerBit.RIGHT, // tslint:disable-line:no-bitwise\r\n  TOP_START = CornerBit.FLIP_RTL,\r\n  TOP_END = CornerBit.FLIP_RTL | CornerBit.RIGHT, // tslint:disable-line:no-bitwise\r\n  BOTTOM_START = CornerBit.BOTTOM | CornerBit.FLIP_RTL, // tslint:disable-line:no-bitwise\r\n  BOTTOM_END = CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL, // tslint:disable-line:no-bitwise\r\n}\r\ninterface IDistance {\r\n  top: number;\r\n  right: number;\r\n  bottom: number;\r\n  left: number;\r\n}\r\n\r\nexport interface IPoint {\r\n  x: number;\r\n  y: number;\r\n}\r\ninterface IAutoLayoutMeasurements {\r\n  anchorSize: IDimensions;\r\n  bodySize: IDimensions;\r\n  surfaceSize: IDimensions;\r\n  viewportDistance: IDistance;\r\n  viewportSize: IDimensions;\r\n  windowScroll: IPoint;\r\n}\r\nclass EzPopWrapper extends HTMLElement {\r\n\r\n\r\n  private beforeCloseHooks:(() => boolean)[] = [];\r\n  private afterCloseHooks: (() => void)[] = [];\r\n  private beforeActiveTabHooks:(() => boolean)[] = [];\r\n  private afterActiveTabHooks: (() => void)[] = [];\r\n  private isSurfaceOpen: any;\r\n  private dimensions: IDimensions;\r\n  private measurements: any;\r\n  private isHoistedElement = false;\r\n  private isFixedPosition = false\r\n  private isHorizontallyCenteredOnViewport = false;\r\n  private anchor: HTMLElement;\r\n  private root: HTMLElement;\r\n  private position: IPoint;\r\n  private anchorCorner: Corner = Corner.TOP_START;\r\n  private maxHeight = 0;\r\n  private openBottomBias = 0;\r\n  private originCorner: Corner = Corner.TOP_START;\r\n  private readonly anchorMargin:\r\n    IDistance = {top: 0, right: 0, bottom: 0, left: 0};\r\n  // TODO isQuickOpen is not use animation\r\n  private isQuickOpen = true;\r\n  private targetItem: HTMLElement;\r\n  constructor() {\r\n    super();\r\n    // element created\r\n    const shadow = this.attachShadow({ mode: 'open' });\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    shadow.adoptedStyleSheets = [stylesheet];\r\n    shadow.innerHTML = `\r\n       <slot name=\"title\" class=\"${style.anchor}\"></slot>\r\n       <slot name=\"pop\" tabIndex=\"-1\" class=\"${style.popSlot}\"></slot>\r\n    `.replace(/[\\s\\n]*\\n[\\s\\n]*/g, '');\r\n  }\r\n\r\n  connectedCallback() {\r\n    // browser calls this method when the element is added to the document\r\n    // (can be called many times if an element is repeatedly added/removed)\r\n    // Only actually parse the stylesheet when the first instance is connected.\r\n    if (stylesheet.cssRules.length == 0) {\r\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n      // @ts-ignore\r\n      stylesheet.replaceSync(style.toString());\r\n    }\r\n    // this.anchor = document.createElement('div')\r\n    // this.anchor.className = style.anchor\r\n    // this.anchor = this.shadowRoot.querySelector(`.${style.anchor}`)\r\n    this.anchor = this.querySelector('[slot=title]');\r\n    this.root = this.shadowRoot.querySelector('slot[name=pop]');\r\n\r\n    this.targetItem = (this.querySelector('[slot=pop]') as HTMLElement);\r\n    this.targetItem.setAttribute('tabIndex', '-1')\r\n\r\n    this.root.addEventListener('click', (e) => {\r\n      e.stopPropagation();\r\n    });\r\n    this.anchor.addEventListener('click', (e) => {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n      this.open();\r\n    });\r\n    /*console.log(this.targetItem)\r\n    this.targetItem.addEventListener('blur', (e) => {\r\n      console.log('blur', e.target)\r\n      let t = e.target as HTMLElement\r\n      while (t != this.targetItem) {\r\n        t = t.parentElement;\r\n        if ( t == document.body ) {\r\n          break\r\n        }\r\n        if ( t == this.targetItem ) {\r\n          this.close();\r\n          break\r\n        }\r\n      }\r\n\r\n      e.preventDefault();\r\n      e.stopPropagation()\r\n    }) */\r\n    document.addEventListener('click', (e) => {\r\n      this.close();\r\n      e.preventDefault();\r\n      e.stopPropagation()\r\n    })\r\n\r\n    const backdrop = document.createElement('div');\r\n    // backdrop.setAttribute('slot', 'pop')\r\n    backdrop.className = style.backdrop\r\n    backdrop.style.cssText = ``.replace(/[\\s\\n]*\\n[\\s\\n]*/g, '');\r\n    this.root.appendChild(backdrop);\r\n  }\r\n\r\n  open() {\r\n    if (this.isSurfaceOpen) {\r\n      return;\r\n    }\r\n    if (this.isQuickOpen) {\r\n      this.isSurfaceOpen = true;\r\n      this.root.classList.add(style.open);\r\n      this.dimensions = this.getInnerDimensions();\r\n      this.autoPosition();\r\n      const target = (this.querySelector('[slot=pop]') as HTMLElement)\r\n      // target.setAttribute('tabIndex', '-1')\r\n      // target.focus({preventScroll: true})\r\n      // this.notifyOpen();\r\n    }\r\n\r\n  }\r\n  close(skipRestoreFocus = false) {\r\n    if (!this.isSurfaceOpen) {\r\n      return;\r\n    }\r\n    // if (this.isQuickOpen) {\r\n      this.isSurfaceOpen = false;\r\n      this.root.classList.remove(style.open);\r\n      this.anchor.classList.remove(IS_OPEN_BELOW);\r\n      // notifyClosing;\r\n    // }\r\n\r\n\r\n  }\r\n\r\n\r\n  getInnerDimensions() :IDimensions{\r\n    return { width:this.anchor.offsetWidth, height: this.anchor.offsetHeight };\r\n  }\r\n  private hasBit(corner: Corner, bit: CornerBit): boolean {\r\n    return Boolean(corner & bit);  // tslint:disable-line:no-bitwise\r\n  }\r\n\r\n  private setBit(corner: Corner, bit: CornerBit): Corner {\r\n    return corner | bit;  // tslint:disable-line:no-bitwise\r\n  }\r\n\r\n  private unsetBit(corner: Corner, bit: CornerBit): Corner {\r\n    return corner ^ bit;\r\n  }\r\n\r\n  private autoPosition() {\r\n\r\n    this.measurements = this.getAutoLayoutMeasurements();\r\n    const corner = this.getOriginCorner();\r\n    const maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);\r\n    const verticalAlignment =\r\n      this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\r\n    let horizontalAlignment =\r\n      this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';\r\n    const horizontalOffset = this.getHorizontalOriginOffset(corner);\r\n    const verticalOffset = this.getVerticalOriginOffset(corner);\r\n    const {anchorSize, surfaceSize} = this.measurements;\r\n\r\n    const position: Partial<IDistance> = {\r\n      [horizontalAlignment]: horizontalOffset,\r\n      [verticalAlignment]: verticalOffset,\r\n    };\r\n\r\n    // Center align when anchor width is comparable or greater than menu\r\n    // surface, otherwise keep corner.\r\n    if (anchorSize.width / surfaceSize.width >\r\n      numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\r\n      horizontalAlignment = 'center';\r\n    }\r\n\r\n    // If the menu-surface has been hoisted to the body, it's no longer relative\r\n    // to the anchor element\r\n    if (this.isHoistedElement || this.isFixedPosition) {\r\n      this.adjustPositionForHoistedElement(position);\r\n    }\r\n\r\n    this.setTransformOrigin(\r\n      `${horizontalAlignment} ${verticalAlignment}`);\r\n    this.setPosition(position);\r\n    this.setMaxHeight(\r\n      maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\r\n\r\n    // If it is opened from the top then add is-open-below class\r\n    if (!this.hasBit(corner, CornerBit.BOTTOM)) {\r\n      this.anchor.classList.add(IS_OPEN_BELOW);\r\n    }\r\n  }\r\n  setPosition (position:  Partial<IDistance>) {\r\n    const rootHTML = this.targetItem as HTMLElement;\r\n    rootHTML.style.left = 'left' in position ? `${position.left}px` : '';\r\n    rootHTML.style.right = 'right' in position ? `${position.right}px` : '';\r\n    rootHTML.style.top = 'top' in position ? `${position.top}px` : '';\r\n    rootHTML.style.bottom = 'bottom' in position ? `${position.bottom}px` : '';\r\n  }\r\n  setMaxHeight(height: string) {\r\n    (this.targetItem as HTMLElement).style.maxHeight = height;\r\n  }\r\n  setTransformOrigin (origin: string) {\r\n    const propertyName = `transform-origin`;\r\n     // (this.root as HTMLElement).style.setProperty(propertyName, origin);\r\n     (this.targetItem as HTMLElement).style.setProperty(propertyName, origin);\r\n  }\r\n  /**\r\n   * Calculates the offsets for positioning the menu-surface when the\r\n   * menu-surface has been hoisted to the body.\r\n   */\r\n  private adjustPositionForHoistedElement(position: Partial<IDistance>) {\r\n    const {windowScroll, viewportDistance, surfaceSize, viewportSize} =\r\n      this.measurements;\r\n\r\n    const props =\r\n      Object.keys(position) as Array<keyof Partial<IDistance>>;\r\n\r\n    for (const prop of props) {\r\n      let value = position[prop] || 0;\r\n\r\n      if (this.isHorizontallyCenteredOnViewport &&\r\n        (prop === 'left' || prop === 'right')) {\r\n        position[prop] = (viewportSize.width - surfaceSize.width) / 2;\r\n        continue;\r\n      }\r\n\r\n      // Hoisted surfaces need to have the anchor elements location on the page\r\n      // added to the position properties for proper alignment on the body.\r\n      value += viewportDistance[prop];\r\n\r\n      // Surfaces that are absolutely positioned need to have additional\r\n      // calculations for scroll and bottom positioning.\r\n      if (!this.isFixedPosition) {\r\n        if (prop === 'top') {\r\n          value += windowScroll.y;\r\n        } else if (prop === 'bottom') {\r\n          value -= windowScroll.y;\r\n        } else if (prop === 'left') {\r\n          value += windowScroll.x;\r\n        } else {  // prop === 'right'\r\n          value -= windowScroll.x;\r\n        }\r\n      }\r\n\r\n      position[prop] = value;\r\n    }\r\n  }\r\n  /**\r\n   * @param corner Origin corner of the menu surface.\r\n   * @return Vertical offset of menu surface origin corner from corresponding\r\n   *     anchor corner.\r\n   */\r\n  private getVerticalOriginOffset(corner: Corner): number {\r\n    const {anchorSize} = this.measurements;\r\n    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\r\n    const avoidVerticalOverlap =\r\n      this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\r\n\r\n    let y = 0;\r\n    if (isBottomAligned) {\r\n      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top :\r\n        -this.anchorMargin.bottom;\r\n    } else {\r\n      y = avoidVerticalOverlap ?\r\n        (anchorSize.height + this.anchorMargin.bottom) :\r\n        this.anchorMargin.top;\r\n    }\r\n    return y;\r\n  }\r\n  /**\r\n   * @param corner Origin corner of the menu surface.\r\n   * @return Horizontal offset of menu surface origin corner from corresponding\r\n   *     anchor corner.\r\n   */\r\n  private getHorizontalOriginOffset(corner: Corner): number {\r\n    const {anchorSize} = this.measurements;\r\n\r\n    // isRightAligned corresponds to using the 'right' property on the surface.\r\n    const isRightAligned = this.hasBit(corner, CornerBit.RIGHT);\r\n    const avoidHorizontalOverlap =\r\n      this.hasBit(this.anchorCorner, CornerBit.RIGHT);\r\n\r\n    if (isRightAligned) {\r\n      const rightOffset = avoidHorizontalOverlap ?\r\n        anchorSize.width - this.anchorMargin.left :\r\n        this.anchorMargin.right;\r\n\r\n      // For hoisted or fixed elements, adjust the offset by the difference\r\n      // between viewport width and body width so when we calculate the right\r\n      // value (`adjustPositionForHoistedElement`) based on the element\r\n      // position, the right property is correct.\r\n      if (this.isHoistedElement || this.isFixedPosition) {\r\n        return rightOffset -\r\n          (this.measurements.viewportSize.width -\r\n            this.measurements.bodySize.width);\r\n      }\r\n\r\n      return rightOffset;\r\n    }\r\n\r\n    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right :\r\n      this.anchorMargin.left;\r\n  }\r\n  private getAnchorDimensions() {\r\n    return this.anchor.getBoundingClientRect();\r\n  }\r\n  private getBodyDimensions(): IDimensions { return  { width: document.body.clientWidth, height: document.body.clientHeight }; }\r\n  private getWindowDimensions(): IDimensions {\r\n    return { width: window.innerWidth, height: window.innerHeight };\r\n  }\r\n  getWindowScroll () {\r\n    // return { x: window.pageXOffset, y: window.pageYOffset };\r\n    return { x: window.scrollX, y: window.scrollY};\r\n  }\r\n  private getAutoLayoutMeasurements() {\r\n    let anchorRect = this.getAnchorDimensions();\r\n    const bodySize = this.getBodyDimensions();\r\n    const viewportSize = this.getWindowDimensions();\r\n    const windowScroll = this.getWindowScroll();\r\n\r\n    if (!anchorRect) {\r\n      // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\r\n      anchorRect = {\r\n        top: this.position.y,\r\n        right: this.position.x,\r\n        bottom: this.position.y,\r\n        left: this.position.x,\r\n        width: 0,\r\n        height: 0,\r\n      } as any;\r\n    }\r\n      return {\r\n        anchorSize: anchorRect!,\r\n        bodySize,\r\n        surfaceSize: this.dimensions,\r\n        viewportDistance: {\r\n          // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\r\n          top: anchorRect!.top,\r\n          right: viewportSize.width - anchorRect!.right,\r\n          bottom: viewportSize.height - anchorRect!.bottom,\r\n          left: anchorRect!.left,\r\n          // tslint:enable:object-literal-sort-keys\r\n        },\r\n        viewportSize,\r\n        windowScroll,\r\n      };\r\n\r\n  }\r\n\r\n  /**\r\n   * @param corner Origin corner of the menu surface.\r\n   * @return Maximum height of the menu surface, based on available space. 0\r\n   *     indicates should not be set.\r\n   */\r\n  private getMenuSurfaceMaxHeight(corner: Corner): number {\r\n    if (this.maxHeight > 0) {\r\n      return this.maxHeight;\r\n    }\r\n\r\n    const {viewportDistance} = this.measurements;\r\n\r\n    let maxHeight = 0;\r\n    const isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\r\n    const isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\r\n    const {MARGIN_TO_EDGE} = numbers;\r\n\r\n    // When maximum height is not specified, it is handled from CSS.\r\n    if (isBottomAligned) {\r\n      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;\r\n      if (!isBottomAnchored) {\r\n        maxHeight += this.measurements.anchorSize.height;\r\n      }\r\n    } else {\r\n      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom +\r\n        this.measurements.anchorSize.height - MARGIN_TO_EDGE;\r\n      if (isBottomAnchored) {\r\n        maxHeight -= this.measurements.anchorSize.height;\r\n      }\r\n    }\r\n\r\n    return maxHeight;\r\n  }\r\n  private setAnchorMargin(margin: Partial<IDistance>) {\r\n      this.anchorMargin.top = margin.top || 0;\r\n      this.anchorMargin.right = margin.right || 0;\r\n      this.anchorMargin.bottom = margin.bottom || 0;\r\n      this.anchorMargin.left = margin.left || 0;\r\n  }\r\n  /**\r\n   * Computes the corner of the anchor from which to animate and position the\r\n   * menu surface.\r\n   *\r\n   * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL\r\n   * context. E.g., menu surface will be positioned from right side on TOP_END.\r\n   */\r\n  private getOriginCorner(): Corner {\r\n    let corner = this.originCorner;\r\n\r\n    const {viewportDistance, anchorSize, surfaceSize} = this.measurements;\r\n    const {MARGIN_TO_EDGE} = numbers;\r\n\r\n    const isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\r\n\r\n    let availableTop;\r\n    let availableBottom;\r\n    if (isAnchoredToBottom) {\r\n      availableTop =\r\n        viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;\r\n      availableBottom =\r\n        viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;\r\n    } else {\r\n      availableTop =\r\n        viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;\r\n      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE +\r\n        anchorSize.height - this.anchorMargin.top;\r\n    }\r\n\r\n    const isAvailableBottom = availableBottom - surfaceSize.height > 0;\r\n    if (!isAvailableBottom &&\r\n      availableTop > availableBottom + this.openBottomBias) {\r\n      // Attach bottom side of surface to the anchor.\r\n      corner = this.setBit(corner, CornerBit.BOTTOM);\r\n    }\r\n\r\n    const isRtl = false; //this.adapter.isRtl();\r\n    const isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);\r\n    const hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) ||\r\n      this.hasBit(corner, CornerBit.RIGHT);\r\n\r\n    // Whether surface attached to right side of anchor element.\r\n    let isAnchoredToRight = false;\r\n\r\n    // Anchored to start\r\n    if (isRtl && isFlipRtl) {\r\n      isAnchoredToRight = !hasRightBit;\r\n    } else {\r\n      // Anchored to right\r\n      isAnchoredToRight = hasRightBit;\r\n    }\r\n\r\n\r\n    let availableLeft;\r\n    let availableRight;\r\n    if (isAnchoredToRight) {\r\n      availableLeft =\r\n        viewportDistance.left + anchorSize.width + this.anchorMargin.right;\r\n      availableRight = viewportDistance.right - this.anchorMargin.right;\r\n    } else {\r\n      availableLeft = viewportDistance.left + this.anchorMargin.left;\r\n      availableRight =\r\n        viewportDistance.right + anchorSize.width - this.anchorMargin.left;\r\n    }\r\n\r\n    const isAvailableLeft = availableLeft - surfaceSize.width > 0;\r\n    const isAvailableRight = availableRight - surfaceSize.width > 0;\r\n    const isOriginCornerAlignedToEnd =\r\n      this.hasBit(corner, CornerBit.FLIP_RTL) &&\r\n      this.hasBit(corner, CornerBit.RIGHT);\r\n\r\n    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl ||\r\n      !isAvailableLeft && isOriginCornerAlignedToEnd) {\r\n      // Attach left side of surface to the anchor.\r\n      corner = this.unsetBit(corner, CornerBit.RIGHT);\r\n    } else if (\r\n      isAvailableLeft && isAnchoredToRight && isRtl ||\r\n      (isAvailableLeft && !isAnchoredToRight && hasRightBit) ||\r\n      (!isAvailableRight && availableLeft >= availableRight)) {\r\n      // Attach right side of surface to the anchor.\r\n      corner = this.setBit(corner, CornerBit.RIGHT);\r\n    }\r\n\r\n    return corner;\r\n  }\r\n\r\n\r\n\r\n  disconnectedCallback() {\r\n    // browser calls this method when the element is removed from the document\r\n    // (can be called many times if an element is repeatedly added/removed)\r\n  }\r\n\r\n  static get observedAttributes(): string[]  {\r\n    return [/* array of attribute names to monitor for changes */];\r\n  }\r\n\r\n  attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n    // called when one of attributes listed above is modified\r\n  }\r\n\r\n  adoptedCallback() {\r\n    // called when the element is moved to a new document\r\n    // (happens in document.adoptNode, very rarely used)\r\n  }\r\n\r\n  // there can be other element methods and properties\r\n}\r\ncustomElements.define(\"ez-pop-wrapper\", EzPopWrapper);\r\n"],"names":["___CSS_LOADER_API_SOURCEMAP_IMPORT___","___CSS_LOADER_EXPORT___","___CSS_LOADER_API_IMPORT___","push","module","id","locals","Proxy","get","target","prop","receiver","Reflect","arguments","exports","cssWithMappingToString","list","toString","this","map","item","content","needLayer","concat","length","join","i","modules","media","dedupe","supports","layer","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","stylesheet","CSSStyleSheet","IS_OPEN_BELOW","numbers","TRANSITION_OPEN_DURATION","TRANSITION_CLOSE_DURATION","MARGIN_TO_EDGE","ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO","TOUCH_EVENT_WAIT_MS","CornerBit","Corner","EzPopWrapper","HTMLElement","constructor","super","beforeCloseHooks","afterCloseHooks","beforeActiveTabHooks","afterActiveTabHooks","isHoistedElement","isFixedPosition","isHorizontallyCenteredOnViewport","anchorCorner","TOP_START","maxHeight","openBottomBias","originCorner","anchorMargin","top","right","bottom","left","isQuickOpen","shadow","attachShadow","mode","adoptedStyleSheets","innerHTML","style","anchor","popSlot","replace","connectedCallback","cssRules","replaceSync","querySelector","root","shadowRoot","targetItem","setAttribute","addEventListener","e","stopPropagation","preventDefault","open","document","close","backdrop","createElement","className","cssText","appendChild","isSurfaceOpen","classList","add","dimensions","getInnerDimensions","autoPosition","skipRestoreFocus","remove","width","offsetWidth","height","offsetHeight","hasBit","corner","bit","Boolean","setBit","unsetBit","measurements","getAutoLayoutMeasurements","getOriginCorner","maxMenuSurfaceHeight","getMenuSurfaceMaxHeight","verticalAlignment","BOTTOM","horizontalAlignment","RIGHT","horizontalOffset","getHorizontalOriginOffset","verticalOffset","getVerticalOriginOffset","anchorSize","surfaceSize","position","adjustPositionForHoistedElement","setTransformOrigin","setPosition","setMaxHeight","rootHTML","origin","setProperty","windowScroll","viewportDistance","viewportSize","props","Object","keys","value","y","x","isBottomAligned","avoidVerticalOverlap","isRightAligned","avoidHorizontalOverlap","rightOffset","bodySize","getAnchorDimensions","getBoundingClientRect","getBodyDimensions","body","clientWidth","clientHeight","getWindowDimensions","window","innerWidth","innerHeight","getWindowScroll","scrollX","scrollY","anchorRect","isBottomAnchored","setAnchorMargin","margin","availableTop","availableBottom","FLIP_RTL","hasRightBit","availableLeft","availableRight","isAnchoredToRight","isAvailableLeft","isAvailableRight","isOriginCornerAlignedToEnd","disconnectedCallback","observedAttributes","attributeChangedCallback","name","oldValue","newValue","adoptedCallback","customElements","define"],"sourceRoot":""}