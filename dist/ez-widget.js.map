{"version":3,"file":"ez-widget.js","mappings":"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","sources":["webpack://ez-web-components/./src/components/ez-widget/fastdom.ts","webpack://ez-web-components/./src/components/ez-widget/index.ts","webpack://ez-web-components/webpack/bootstrap","webpack://ez-web-components/webpack/startup"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nconst fd = (function(win) {\n// const win = ( typeof window !== 'undefined' ? window : this)\n  /**\n   * FastDom\n   *\n   * Eliminates layout thrashing\n   * by batching DOM read/write\n   * interactions.\n   *\n   * @author Wilson Page <wilsonpage@me.com>\n   * @author Kornel Lesinski <kornel.lesinski@ft.com>\n   */\n\n  'use strict';\n\n  /**\n   * Mini logger\n   *\n   * @return {Function}\n   */\n  var debug = 0 ? console.log.bind(console, '[fastdom]') : function() {};\n\n  /**\n   * Normalized rAF\n   *\n   * @type {Function}\n   */\n  var raf = win.requestAnimationFrame\n      || win.webkitRequestAnimationFrame\n      || win.mozRequestAnimationFrame\n      || win.msRequestAnimationFrame\n      || function(cb) { return setTimeout(cb, 16); };\n\n  /**\n   * Initialize a `FastDom`.\n   *\n   * @constructor\n   */\n  function FastDom() {\n    var self = this;\n    self.reads = [];\n    self.writes = [];\n    self.raf = raf.bind(win); // test hook\n    debug('initialized', self);\n  }\n\n  FastDom.prototype = {\n    constructor: FastDom,\n\n    /**\n     * We run this inside a try catch\n     * so that if any jobs error, we\n     * are able to recover and continue\n     * to flush the batch until it's empty.\n     *\n     * @param {Array} tasks\n     */\n    runTasks: function(tasks) {\n      debug('run tasks');\n      var task; while (task = tasks.shift()) task();\n    },\n\n    /**\n     * Adds a job to the read batch and\n     * schedules a new frame if need be.\n     *\n     * @param  {Function} fn\n     * @param  {Object} ctx the context to be bound to `fn` (optional).\n     * @public\n     */\n    measure: function(fn, ctx) {\n      debug('measure');\n      var task = !ctx ? fn : fn.bind(ctx);\n      this.reads.push(task);\n      scheduleFlush(this);\n      return task;\n    },\n\n    /**\n     * Adds a job to the\n     * write batch and schedules\n     * a new frame if need be.\n     *\n     * @param  {Function} fn\n     * @param  {Object} ctx the context to be bound to `fn` (optional).\n     * @public\n     */\n    mutate: function(fn, ctx) {\n      debug('mutate');\n      var task = !ctx ? fn : fn.bind(ctx);\n      this.writes.push(task);\n      scheduleFlush(this);\n      return task;\n    },\n\n    /**\n     * Clears a scheduled 'read' or 'write' task.\n     *\n     * @param {Object} task\n     * @return {Boolean} success\n     * @public\n     */\n    clear: function(task) {\n      debug('clear', task);\n      return remove(this.reads, task) || remove(this.writes, task);\n    },\n\n    /**\n     * Extend this FastDom with some\n     * custom functionality.\n     *\n     * Because fastdom must *always* be a\n     * singleton, we're actually extending\n     * the fastdom instance. This means tasks\n     * scheduled by an extension still enter\n     * fastdom's global task queue.\n     *\n     * The 'super' instance can be accessed\n     * from `this.fastdom`.\n     *\n     * @example\n     *\n     * var myFastdom = fastdom.extend({\n     *   initialize: function() {\n     *     // runs on creation\n     *   },\n     *\n     *   // override a method\n     *   measure: function(fn) {\n     *     // do extra stuff ...\n     *\n     *     // then call the original\n     *     return this.fastdom.measure(fn);\n     *   },\n     *\n     *   ...\n     * });\n     *\n     * @param  {Object} props  properties to mixin\n     * @return {FastDom}\n     */\n    extend: function(props) {\n      debug('extend', props);\n      if (typeof props != 'object') throw new Error('expected object');\n\n      var child = Object.create(this);\n      mixin(child, props);\n      child.fastdom = this;\n\n      // run optional creation hook\n      if (child.initialize) child.initialize();\n\n      return child;\n    },\n\n    // override this with a function\n    // to prevent Errors in console\n    // when tasks throw\n    catch: null\n  };\n\n  /**\n   * Schedules a new read/write\n   * batch if one isn't pending.\n   *\n   * @private\n   */\n  function scheduleFlush(fastdom) {\n    if (!fastdom.scheduled) {\n      fastdom.scheduled = true;\n      fastdom.raf(flush.bind(null, fastdom));\n      debug('flush scheduled');\n    }\n  }\n\n  /**\n   * Runs queued `read` and `write` tasks.\n   *\n   * Errors are caught and thrown by default.\n   * If a `.catch` function has been defined\n   * it is called instead.\n   *\n   * @private\n   */\n  function flush(fastdom) {\n    debug('flush');\n\n    var writes = fastdom.writes;\n    var reads = fastdom.reads;\n    var error;\n\n    try {\n      debug('flushing reads', reads.length);\n      fastdom.runTasks(reads);\n      debug('flushing writes', writes.length);\n      fastdom.runTasks(writes);\n    } catch (e) { error = e; }\n\n    fastdom.scheduled = false;\n\n    // If the batch errored we may still have tasks queued\n    if (reads.length || writes.length) scheduleFlush(fastdom);\n\n    if (error) {\n      debug('task errored', error.message);\n      if (fastdom.catch) fastdom.catch(error);\n      else throw error;\n    }\n  }\n\n  /**\n   * Remove an item from an Array.\n   *\n   * @param  {Array} array\n   * @param  {*} item\n   * @return {Boolean}\n   */\n  function remove(array, item) {\n    var index = array.indexOf(item);\n    return !!~index && !!array.splice(index, 1);\n  }\n\n  /**\n   * Mixin own properties of source\n   * object into the target.\n   *\n   * @param  {Object} target\n   * @param  {Object} source\n   */\n  function mixin(target, source) {\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) target[key] = source[key];\n    }\n  }\n\n// There should never be more than\n// one instance of `FastDom` in an app\n\n  return win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line\n  // export const fd = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line\n  // export default exports\n// Expose to CJS & AMD\n//   if ((typeof define) == 'function') define(function() { return exports; });\n//   else if ((typeof module) == 'object') module.exports = exports;\n//   else return exports\n\n})( typeof window !== 'undefined' ? window : this);\nexport default  fd;\n","import style from \"./style.less\";\n// console.log('style', typeof style.toString())\nimport fastdom from './fastdom';\n// const fastdom = require('./fastdom')\n// import  './fastdom';\n\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst randomLocalsScopeName = `___$locals$___${Date.now()}`\nconst randomSourceScopeName = `___$source$___${Date.now()}`\nconst IS_PROXY = Symbol(\"IS_PROXY\")\nconst PARENT_PATH = Symbol(\"PARENT_PATH\")\ntype VAR_AND_EXPRESSION = {\n  expression: string;\n  vars: Set<string>;\n  monitState?: boolean,\n  runtimeFn?: CallableFunction\n}\nenum LOOP_CONDITION_STATEMENT {\n  CONTINUE,\n  BREAK,\n  RETURN,\n  NOTHING\n}\nconst EXPRESSION_REGEX = /{([^{}]+?)}/g;\n\nenum DOM_RENDER_ACTION_TYPE {\n  REPLACE,\n  REORDER,\n  ATTRS,\n  TEXT\n}\n\ntype ACTOR = (...args: any) => void|CallableFunction;\n\ntype iterableObj<T> = {\n  [key: string]: T\n  // [Symbol.iterator]: T\n  // [Symbol.iterator]() : IterableIterator<any>;\n};\n\ntype VELEMENT  = (HTMLElement ) & {\n  detach: () => void;\n  ___bind_meta?: any;\n  ___uniqueItemKey?:string|symbol;\n  ___ez_compiled: boolean;\n  compileContext: iterableObj<any>} & {\n  [propName: string]: any;\n}\ntype EXPRESSION_ACTION = (...args: any) => void;\n\n// https://gist.github.com/seanlinsley/bc10378fd311d75cf6b5e80394be813d\nclass ___IterableWeakSet<T> extends Set {\n  add(el: any) {\n    for (const ref of super.values()) {\n      const value = ref.deref()\n      if (value == el) {\n        return this\n      }\n    }\n    // const ref = new WeakRef(el);\n    super.add(new WeakRef(el))\n    return this\n  }\n\n  forEach(fn: CallableFunction) {\n    super.forEach((ref, index) => {\n      const value = ref.deref()\n      if (value) {fn(value, ref)} else {\n        super.delete(ref)\n      }\n    })\n  }\n  *[Symbol.iterator]() {\n    for (const ref of super.values()) {\n      const value = ref.deref()\n      if (value) yield value\n    }\n  }\n}\nclass IterableWeakSet<T> {\n  private __set: Set<any>;\n  constructor() {\n    this.__set = new Set();\n  }\n  deleteByValue(el: any) {\n    for (const ref of this.__set.values()) {\n      const value = ref.deref()\n      if (value == el) {\n        this.__set.delete(ref)\n      }\n    }\n  }\n  deleteByRef(ref: WeakRef<any>) {\n    this.__set.delete(ref)\n  }\n  add(el: any) {\n    for (const ref of this.__set.values()) {\n      const value = ref.deref()\n      if (value == el) {\n        return ref\n      }\n    }\n    const ref = new WeakRef(el);\n    this.__set.add(ref)\n    return ref\n  }\n\n  forEach(fn: CallableFunction) {\n    this.__set.forEach((ref) => {\n      const value = ref.deref()\n      if (value) {\n        fn(value, ref)\n      } else {\n        this.__set.delete(ref)\n      }\n    })\n  }\n  *[Symbol.iterator]() {\n    for (const ref of this.__set.values()) {\n      const value = ref.deref()\n      if (value) yield value\n    }\n  }\n}\nclass IterableWeakMap<K extends object, V> {\n  private keysSet: IterableWeakSet<K>;\n  private valueStore: WeakMap<K, V>;\n  constructor() {\n    this.keysSet = new IterableWeakSet<object>();\n    this.valueStore = new WeakMap<K, V>();\n  }\n  forEach(fn: CallableFunction) {\n    this.keysSet.forEach((k: K) => {\n      const v = this.valueStore.get(k);\n      fn(v)\n    })\n  }\n  *[Symbol.iterator]() {\n    for (const k of this.keysSet) {\n      yield [k, this.valueStore.get(k)]\n    }\n  }\n  clear(){\n    this.keysSet.forEach((item: K) => {\n      this.valueStore.delete(item);\n    })\n  }\n  delete(key: K){\n    this.keysSet.deleteByValue(key);\n    return this.valueStore.delete(key);\n  }\n  get(key: K){\n    return this.valueStore.get(key);\n  }\n  has(key: K){\n    return this.valueStore.has(key);\n  }\n  set(key: K, value: V){\n    return this.valueStore.set(key, value);\n  }\n\n}\n\nclass ActorRefRunCounter {\n  private __actorRunCounter: IterableWeakMap<object, number>;\n  constructor() {\n    this.__actorRunCounter = new IterableWeakMap();\n  }\n  add(act: ACTOR){\n    const val = this.__actorRunCounter.get(act);\n    if (val > 100) {\n      // copy from vue\n      throw new Error(`Maximum recursive updates exceeded in component. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`)\n    }\n    if (!val) {\n      this.__actorRunCounter.set(act, 1)\n    } else {\n      this.__actorRunCounter.set(act, val + 1)\n    }\n\n  }\n  reset() {\n    this.__actorRunCounter.clear()\n  }\n}\n\n\nclass DirtyableValue  {\n  private _value: any;\n  private _dirty= false;\n  private _pathKey = '';\n  static isPrimitiveValue(value: undefined |null |boolean | number | string | symbol): boolean {\n    if (value === null) {\n      return true;\n    }\n    const t = typeof value;\n    const primitiveTypes = ['undefined' , 'boolean', 'number', 'string', 'symbol']\n    return primitiveTypes.includes(t)\n  }\n  constructor(value: any, pathKey:string) {\n\n\n    this._value = value;\n    this._pathKey = pathKey;\n  }\n\n\n\n  get value() {\n    return this._value\n  }\n  set value (val: any){\n    this._dirty = true;\n    this._value = val;\n  }\n  get isDirty () {\n    return this._dirty;\n  }\n  reset() {\n    this._dirty = false;\n  }\n  toString () {\n    // return `<DirtyableValue>${this._value}`;\n    return this._value;\n  }\n  valueOf () {\n    return this._value;\n  }\n\n}\nfunction isReflectable(v: any) {\n  // FIXME to do with or without Array\n  return v != null && typeof v !== 'function' &&  !Array.isArray(v) && typeof v == 'object';\n  // return !(v != null &&  !Array.isArray(v) && typeof v !== 'function' && typeof v !== 'object');\n}\nconst toCamel = (s: string) => {\n  return s.replace(/([-_][a-z])/ig, ($1: string) => {\n    return $1.toUpperCase()\n      .replace('-', '')\n      .replace('_', '');\n  });\n};\n\n\n// https://stackoverflow.com/questions/543533/restricting-eval-to-a-narrow-scope\n// https://stackoverflow.com/questions/61552/are-there-legitimate-uses-for-javascripts-with-statement\nfunction ___lambda(exp: string,ctx={}, node:any=null) {\n  if (node) {\n    ctx = new Proxy(ctx,{\n      has:()=>true,\n      get: (target: any, prop: string, receiver) => {\n        console.log( prop, prop in target)\n        return Reflect.get(target, prop, receiver);\n      },\n    })\n  }\n\n  // execute script in private context\n  const func = (new Function( `with(this) {\n   try {\n    return ${exp};\n   } catch(e) {\n   }\n  }`));\n  return func.call(ctx);\n}\n\nconst lambda: CallableFunction = (function(){\n  const cache: {[key: string]: CallableFunction} = {};\n\n  function expressionTemplate(exp: string){\n    let fn = cache[exp];\n    if (!fn){\n      // fn =(new Function( 'ctx', `with(ctx) { try {return ${exp};} catch(r) {}}`));\n      // fn =(new Function( 'ctx', `with(ctx) { return ${exp};}`));\n      try{\n        fn = (new Function( `ctx, ${randomSourceScopeName}, ${randomLocalsScopeName}`, `\n        if (!${randomLocalsScopeName} || !Object.keys(${randomLocalsScopeName}).length) {\n          ${randomLocalsScopeName} = {};\n        };\n        if (!${randomSourceScopeName}|| !Object.keys(${randomSourceScopeName}).length) {\n          ${randomSourceScopeName} = {};\n        };\n        with(ctx) {\n          with(${randomSourceScopeName}) {\n            with(${randomLocalsScopeName}) { \n              return  ${exp};\n            }\n          }\n          \n        }`))\n      } catch (e) {\n        throw new Error(`[Template Compile Error] SyntaxError:${e.message}`)\n      }\n      cache[exp] = fn;\n    }\n    return fn;\n  }\n  return expressionTemplate;\n})();\n\n\n\nconst stylesheet = new CSSStyleSheet();\nconst slice = Array.prototype.slice\n// const varNodeMap: {\n//   [key: string]: Set<VELEMENT>\n// } = {};\n// const varActionMap: {\n//   [key: string]: Set<any>\n// } = {};\n\n\n\n\nfunction treeWalker(node: HTMLElement|Node, compile: (n: VELEMENT) => void) {\n  if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    let curChild = node.firstChild;\n    while (curChild) {\n      // console.log('[nodeName]',curChild.nodeName)\n      compile(curChild as VELEMENT)\n      treeWalker(curChild, compile);\n      curChild = curChild.nextSibling;\n    }\n  }\n}\nfunction walk(nodes: Node|Node[]|NodeListOf<ChildNode>, check: (n: VELEMENT) => LOOP_CONDITION_STATEMENT) {\n  if (!('length' in nodes)) {\n    nodes = [nodes]\n  }\n\n  nodes = slice.call(nodes)\n\n  while((nodes as VELEMENT[]).length) {\n    const node = (nodes as  VELEMENT[]).shift()\n    node.normalize();\n    const ret = check(node)\n\n    if (ret === LOOP_CONDITION_STATEMENT.CONTINUE) {\n      continue\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.BREAK) {\n      break\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.RETURN) {\n      return\n    }\n\n    if (node.childNodes && node.childNodes.length) {\n      nodes = slice.call(node.childNodes).concat(nodes)\n    }\n  }\n}\nfunction compileWalker(nodes: Node|Node[]|NodeListOf<ChildNode>, compile: (n: VELEMENT) => LOOP_CONDITION_STATEMENT) {\n  if (!('length' in nodes)) {\n    nodes = [nodes]\n  }\n  nodes = slice.call(nodes)\n  while((nodes as VELEMENT[]).length) {\n    const node = (nodes as  VELEMENT[]).shift()\n    node.normalize();\n    const ret = compile(node)\n    if (ret === LOOP_CONDITION_STATEMENT.CONTINUE) {\n      continue\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.BREAK) {\n      break\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.RETURN) {\n      return\n    }\n    if (node.childNodes && node.childNodes.length) {\n      nodes = slice.call(node.childNodes).concat(nodes)\n    }\n  }\n}\n\n// https://javascript.info/mutation-observer\nfunction watchDom(fragment: Node, check: (n: VELEMENT) => LOOP_CONDITION_STATEMENT) {\n  const mutationRecords = [];\n  const callback = function(mutationsList: MutationRecord[], observer: MutationObserver) {\n    console.log(mutationsList, observer );\n    // // Use traditional 'for loops' for IE 11\n    // for(const mutation of mutationsList) {\n    //   if (mutation.type === 'childList') {\n    //     console.log('A child node has been added or removed.');\n    //   }\n    //   else if (mutation.type === 'attributes') {\n    //     console.log('The ' + mutation.attributeName + ' attribute was modified.');\n    //   }\n    // }\n  };\n  const observer = new MutationObserver(callback);\n  // Start observing the target node for configured mutations\n  observer.observe(fragment, {\n    childList: true, // observe direct children\n    subtree: true, // and lower descendants too\n    attributes: true,\n    attributeOldValue: true,\n    characterDataOldValue: true, // pass old data to callback\n    characterData: true,\n  });\n\n  try{\n    walk(fragment.childNodes, check)\n  } catch(e) {\n    //\n  } finally {\n    // get a list of unprocessed mutations\n    // should be called before disconnecting,\n    // if you care about possibly unhandled recent mutations\n    const unhandledMutationRecords = observer.takeRecords();\n    unhandledMutationRecords.forEach(MutationRecord => mutationRecords.push(MutationRecord))\n    // Later, you can stop observing\n    observer.disconnect();\n  }\n}\nfunction subStrAtPos(tpl: string, step: number , pos: number) {\n  const f = []\n  for (let i = 0; i < step; i++) {\n    const s = tpl[pos + i]\n    if (s) {\n      f.push(s)\n    }\n  }\n  return f.join('')\n}\n\n\nfunction extractVarsV2(template: string, openChar = \"{\", closeChar = \"}\") {\n\n  let i = 0;\n  const ol = openChar.length;\n  const cl = closeChar.length;\n  const tl = template.length;\n  const data = [];\n  const sq = [];\n  const dq = [];\n  do {\n    if (template.substring(i, i+ol) == openChar) {\n      for (let j=i+1; j<=(tl - cl ); j++) {\n        if (template[j] === \"'\") {\n          sq.length & 1 ? sq.pop() : sq.push(null);\n        }\n\n        if (template[j] === '\"') {\n          dq.length & 1 ? dq.pop() : dq.push(null);\n        }\n        if(template.substring(j, j+ol) == openChar && !sq.length && !dq.length) {\n          i = j\n        }\n\n        if (template.substring(j, j+cl) == closeChar && ( !sq.length && !dq.length )  ) {\n          sq.length = 0;\n          dq.length = 0;\n          const start = i;\n          const end = j+cl;\n          data.push({\n            start,\n            end,\n            expName: template.slice(start, end).trim(),\n            varName: template.slice(start + ol, j).trim()\n          })\n          i = j+1;\n          break;\n        }\n      }\n    }\n  } while (++i <= (template.length - openChar.length ))\n\n  return data;\n}\nfunction replaceAllWithoutRegex(s: string, oldStr: string, newStr: string) {\n  // let index = 0;\n  // do {\n  //   s = s.replace(oldStr, newStr);\n  // } while((index = s.indexOf(oldStr, index + 1)) > -1);\n\n  const fromLen = oldStr.length;\n  const output = [];\n  let pos = 0;\n  for (;;) {\n    let matchPos = s.indexOf(oldStr, pos);\n    if (matchPos === -1) {\n      // output += s.slice(pos);\n      output.push(s.slice(pos))\n      break;\n    }\n    // output += s.slice(pos, matchPos);\n    output.push(s.slice(pos, matchPos))\n    // output += newStr;\n    output.push(newStr)\n    pos = matchPos + fromLen;\n  }\n  return output.join('');\n}\nfunction extractVarsFromObject(obj: any, str: string) {\n  const ks = Object.keys(obj).filter(k => {\n    // return typeof obj[k] != 'function' && typeof obj[k] != 'object'\n    // return typeof obj[k] != 'object'\n    return obj[k].constructor.name != 'Object';\n  })\n  // const re = new RegExp(`\\\\b(?:${ks.join('|')})\\\\b`.replaceAll('.', `\\\\.`), 'g')\n  const re = new RegExp(`\\\\b(?:${ks.join('|')})\\\\b`.replace(/\\./, `\\\\.`), 'g')\n  return str.match(re) || []\n}\n\n\n\nfunction bindFunctionScope(ctx: any, fn: () => void) {\n  return (function() {\n    return eval(fn.toString());\n  }).call(ctx);\n}\n\nconst StateHandle: ProxyHandler<any> = {\n  has:(target: any, p) => {\n    if (p === randomLocalsScopeName) {\n      return false;\n    }\n    if (p === randomSourceScopeName) {\n      return false;\n    }\n    return true;\n  },\n  get(target: any, prop: string|symbol, receiver) {\n    console.log('[internal][state][GET]', prop)\n    if (prop === IS_PROXY) {\n      return true;\n    }\n    // if (prop === 'ctx') {\n    //   return receiver;\n    // }\n\n    if (prop === 'startRecordExpressionVars') {\n      this.recordExpressionVars = new WeakSet()\n      return () => {\n        //\n      };\n    }\n    if (prop === 'stopRecordExpressionVars') {\n      // TODO 如果一个函数内没执行到的块里的变量将记录不到, 咋处理?\n      // 除非返回全部state内变量, 或者通过编译,通过Acorn语法树提取变量\n      return () => {\n        const result = Object.keys(target);\n        // const result = Array.from(this.recordExpressionVars)\n        try{\n          return result;\n        } finally {\n          this.recordExpressionVars.clear();\n          delete this.recordExpressionVars;\n        }\n      }\n\n\n    }\n\n    // let value = target[prop];\n    // return (typeof value === 'function') ? value.bind(target) : value; // (*)\n\n    if (typeof prop != 'symbol' && Object.prototype.hasOwnProperty.call(target, prop)) {\n      if (this.recordExpressionVars) {\n        // const parent = Object.getOwnPropertyDescriptor(receiver, PARENT_PATH);\n        const parent = receiver[PARENT_PATH]\n        let varName = prop;\n        if (parent) {\n          varName = `${parent}.${String(prop)}`;\n        }\n        this.recordExpressionVars.add(varName);\n        console.log( '__state get', prop, prop in target)\n      }\n      // 引起循环调用，应该规避掉循环调用还是注释下面凑合\n      // if (typeof target[prop] === 'function') {\n        // if (this.recordExpressionVars) {\n        //   return target[prop].call(receiver);\n        // } else {\n        //   return target[prop]();\n        // }\n      // }\n\n    }\n    /*if (prop != Symbol.unscopables && String(prop).includes('.')) {\n      const props = String(prop).split('.');\n      const final = props.pop();\n      let layer = target;\n      let p = null;\n      for (let i = 0; i < props.length; i++) {\n        p = props[i];\n        if (typeof layer[p] === 'undefined') {\n          return undefined\n          // layer[p] =  new StateProxy({});\n        }\n        layer = layer[p]\n      }\n      return layer[final];\n    }*/\n    return Reflect.get(target, prop, receiver);\n  },\n  set(target: any, prop: string|symbol, val, receiver) { // to intercept property writing\n    console.log('[internal][state][SET]', prop)\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\n      // return true;\n      // throw new Error(`property ${String(prop)} has already been set`);\n    }\n    let newVal = val\n    if (isReflectable(val)) {\n      newVal = new StateProxy(val);\n    }\n    if (val && typeof val === 'function') {\n      // TODO should I make arrow function bind state?\n      // https://github.com/flycrum/check-is-arrow-function/blob/master/src/lib/checkIsArrowFunction.ts\n    }\n    // if (prop === 'objPath') {\n    //   return this.objPath.push(prop);\n    // }\n    // (receiver as any).WATCH_PATH = prop\n\n    /*if (prop != Symbol.unscopables && String(prop).includes('.')) {\n      const props = String(prop).split('.');\n      const final = props.pop()\n      let p = null;\n      const objPath = [];\n      for (let i = 0; i < props.length; i++) {\n        p = props[i];\n        objPath.push(p)\n        if (typeof target[p] === 'undefined') {\n          // If we're setting\n          if (typeof newVal !== 'undefined') {\n            // If we're not at the end of the props, keep adding new empty objects\n            if (i != props.length)\n              target[p] = {}; // new StateProxy({});\n              const pt = objPath.join('.');\n              Object.defineProperty(target[p],\n                PARENT_PATH,\n                {\n                  value: pt,\n                  configurable: false,\n                  enumerable: false,\n                  writable: false,\n                  });\n          }\n          else\n            return undefined;\n        }\n        target = target[p]\n      }\n      // target[final] = newVal;\n      return Reflect.set(target, final, newVal, receiver);\n    }*/\n    return Reflect.set(target, prop, newVal, receiver);\n  },\n  deleteProperty(target: any, prop: string) { // to intercept property deletion\n    // delete target[prop];\n    // return true;\n    return Reflect.deleteProperty(target, prop);\n  },\n  getOwnPropertyDescriptor(target, prop) {\n    let value = undefined;\n    /*if (prop != Symbol.unscopables && String(prop).includes('.')) {\n      const props = String(prop).split('.');\n      const final = props.pop();\n      let layer = target;\n      let p = null;\n      for (let i = 0; i < props.length; i++) {\n        p = props[i];\n        if (typeof layer[p] === 'undefined') {\n          return undefined\n        }\n        layer = layer[p]\n      }\n      value = layer[final];\n    } else {*/\n      value = Object.prototype.hasOwnProperty.call(target, prop)\n    // }\n    if (value && value != undefined) {\n      return {\n        value : value,\n        //use a logical set of descriptors:\n        enumerable : true,\n        configurable : true,\n        writable : true\n      };\n    }\n\n  },\n  ownKeys(target: any) { // to intercept property list\n    // return Object.keys(target).filter(key => !key.startsWith('_'));\n    return Reflect.ownKeys(target);\n  }\n\n}\n\n\n\n\nclass StateProxy<T> {\n  constructor(source: T) {\n    return new Proxy(source, StateHandle);\n  }\n}\n\n\n\nconst loopNestedObj = (obj: any) => {\n  Object.entries(obj).forEach(([key, val]) => {\n    if (isReflectable(val)) {\n      obj[key] = loopNestedObj(val);\n    } else { // or do something with key and val.\n      console.log(key, val);\n      //do nothing\n    }\n  });\n  return new StateProxy(obj)\n};\n\n\nexport class EzWidget extends HTMLElement {\n\n  private __state: Record<string, any> = new StateProxy<Record<string, any>>({});\n\n  private varExpressionObj: {[key: string]: Set<EXPRESSION_ACTION|Node>} = {};\n  private expressionNodeMap = new WeakMap();\n\n  private nodePositionMap = new WeakMap();\n  private compileContentNodeMap = new WeakMap();\n\n  public nodeActorsMap = new WeakMap<VELEMENT|Text, Set<ACTOR>>()\n  public varBindNodeObj: {[key: string]:  IterableWeakSet<any>} = {};\n  public nodeBindVarObj = new WeakMap<VELEMENT|Text, Set<string>>();\n  public varBindActorsMap: {[key: string]:  Set<ACTOR>} = {};\n\n  // weakmap cannot loop\n  public nodeBindActorsMap = new WeakMap<VELEMENT|Text, Set<ACTOR>>();\n  public fnNodesSet = new  IterableWeakSet<VELEMENT|Text>();\n  private actorRefCounter = new ActorRefRunCounter();\n\n  private cacheIfTagDomFragment: DocumentFragment;\n  private cacheLoopTagDomFragment: DocumentFragment;\n\n  // for internal change value\n  private sourceRef: any;\n  private gcRegistry: FinalizationRegistry<unknown>;\n\n  constructor() {\n    super();\n    // console.log('constructor')\n    // element created\n    const shadow = this.attachShadow({ mode: 'open' });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    shadow.adoptedStyleSheets = [stylesheet];\n\n\n    shadow.innerHTML = `\n       <slot></slot>\n    `.replace(/[\\s\\n]*\\n[\\s\\n]*/g, '');\n\n    this.gcRegistry = new FinalizationRegistry(heldValue => {\n      console.log('gcRegistry', heldValue)\n      // ....\n    });\n  }\n\n  connectedCallback() {\n    // browser calls this method when the element is added to the document\n    // (can be called many times if an element is repeatedly added/removed)\n    // Only actually parse the stylesheet when the first instance is connected.\n    if (stylesheet.cssRules.length == 0) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      //   stylesheet.replaceSync(style.toString());\n    }\n\n\n    // const tmpl = document.querySelector('template');\n    // const dom = tmpl.content.cloneNode(true);\n\n    // const tmpl = this.shadowRoot.querySelector('slot');\n    // this.vdom = tmpl.cloneNode(true);\n\n    this.cacheIfTagDomFragment = document.createDocumentFragment();\n    this.cacheLoopTagDomFragment = document.createDocumentFragment();\n    /*this.originalDomFragment = document.createDocumentFragment();\n    // // this.calcDomFragment = document.createDocumentFragment();\n    while (false && this.childNodes.length) {\n      const n = this.childNodes[0];\n      if(n.nodeType == COMMENT_NODE\n        || n.nodeType == DOCUMENT_FRAGMENT_NODE\n        || n.nodeName == 'SCRIPT') {\n        n.remove()\n        continue;\n      }\n    //   console.log(n);\n      this.originalDomFragment.appendChild(n)\n    //   this.originalDomFragment.appendChild(n.cloneNode(true))\n    //   // this.calcDomFragment.appendChild(n);\n    }*/\n    this.dispatchEvent(new CustomEvent('created', {bubbles: true,detail: this}));\n    // console.log(22222)\n    // walk(this.originalChildNodes.childNodes, (node) => {\n    //   this.rendererNodeMap.set(node, node.cloneNode())\n    //   this.calcChildNodes.appendChild(node)\n    //   return LOOP_CONDITION_STATEMENT.NOTHING\n    // })\n    // walk(this.originalDomFragment.childNodes, this.check)\n    compileWalker(this.childNodes, this.compile)\n    // walkTree(this, this.compile)\n    // walk(this.originalChildNodes.cloneNode(true), this.check)\n    // tmpl.remove()\n    // this.shadowRoot.append(dom);\n    this.dispatchEvent( new CustomEvent('mounted', {detail: this}));\n  }\n\n  render() {\n    //\n  }\n\n\n  getInternalKey(key: string) {\n    // return `__ez__|${key}`\n    return key\n  }\n  makeStateReflectable(state: {[p: string]: any}, source: any, root='') {\n    // console.log('root', root);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = source[key]\n      const pathKey = `${root ? `${root}.` : ''}${key}`;\n      const internalKey = this.getInternalKey(pathKey)\n      // console.log('internalKey', internalKey)\n      // if (DirtyableValue.isPrimitiveValue(val)) {\n      //   val = new DirtyableValue(val, internalKey);\n      // }\n      state[internalKey] = val; // new DirtyableValue(val, internalKey);\n      if (typeof val === 'function') {\n        continue\n      }\n\n      if (isReflectable(val)) {\n        self.makeStateReflectable(state, val, pathKey);\n        continue;\n      }\n      Object.defineProperty(source, key, {\n        get() { // ? 嵌套Object，应该从内部__state取还是外部source取？，内部外部取都会产生循环调用\n          console.log('[external][state] [GET]',internalKey, state[internalKey]);\n          return state[internalKey];\n        },\n\n        set(value) {\n          console.log('[external][state] [SET]', internalKey, value);\n          if (isReflectable(value)) {\n            self.makeStateReflectable(state, value, pathKey);\n            return\n          }\n          if (typeof value === 'function') {debugger\n            // self.__state[internalKey] = self.bindStateFunction(value)\n            value = bindFunctionScope(source ,value)\n          }\n          const beforeValue = state[internalKey];\n          if (beforeValue === value) {\n            return\n          }\n          state[internalKey] = value // new DirtyableValue(value, internalKey);\n          console.log(1000, internalKey)\n          const actors = self.varBindActorsMap[internalKey];\n          actors && self.runActors(actors);\n          self.fnNodesSet.forEach((el: any) => {\n            const actors = self.nodeBindActorsMap.get(el);\n            actors && self.runActors(actors);\n          });\n\n\n\n\n          // self.varBindActorsMap\n          // self.nodeBindActorsMap\n          return\n          const nodes = self.varBindNodeObj[internalKey];\n          nodes && nodes.forEach((node: any, ref: WeakRef<any>) => {\n            console.log(999, node)\n            const actors = self.nodeActorsMap.get(node);\n            actors.forEach((act: CallableFunction) => {\n              console.log(998, act);\n              fastdom.mutate(() => {\n                act();\n              })\n            });\n          });\n        }\n      });\n    }\n  }\n  runActors(actors: Set<ACTOR>) {\n    actors.forEach((act: ACTOR) => {\n      this.actorRefCounter.add(act);\n      console.log('run actor')\n      fastdom.mutate(() => {\n        act();\n      })\n    });\n  }\n  setState(source: any) {\n    this.sourceRef = source;\n    this.makeStateReflectable(this.__state, source);\n    this.render();\n  }\n  removeNode(node: VELEMENT) {\n    // const index = Array.from(node.parentNode.children).indexOf(node);\n    const next = node.nextSibling\n    const prev = node.previousSibling\n    this.nodePositionMap.set(node, {\n      parent: node.parentElement,\n      next,\n      prev\n    });\n    this.cacheIfTagDomFragment.appendChild(node);\n  }\n  restoreRemoveNode(node: VELEMENT) {\n    const info = this.nodePositionMap.get(node);\n    if (!info) {\n      return;\n    }\n    const {parent, next, prev} = info;\n    if (!next) {\n      parent.appendChild(node);\n      return\n    }\n    parent.insertBefore(node, next)\n  }\n\n\n\n\n\n  getNodeCompileScope(node: VELEMENT| Text): any {\n    const parent = node.parentNode;\n    const parentScope = this.compileContentNodeMap.get(parent);\n    const nodeScope = this.compileContentNodeMap.get(node);\n    return {...parentScope, ...nodeScope};\n\n    // let parent = node;\n    // let mergedScope = {}\n    // while ((parent as HTMLElement) != this) {\n    //   const scope = this.compileContentNodeMap.get(parent);\n    //   if (scope) {\n    //     mergedScope = {...scope, ...mergedScope}\n    //   }\n    //   parent = parent.parentElement as VELEMENT\n    // }\n    // return mergedScope\n  }\n  bindVarToNode(varName: string, node: VELEMENT) {\n    if (!this.varBindNodeObj[varName]) {\n      this.varBindNodeObj[varName] = new IterableWeakSet<VELEMENT>();\n    }\n    this.varBindNodeObj[varName].add(node)\n    if (!this.nodeBindVarObj.get(node)) {\n      this.nodeBindVarObj.set(node, new Set<string>())\n    }\n    this.nodeBindVarObj.get(node).add(varName)\n  }\n  bindNodePropAction(node: VELEMENT, attrName: string, attrValue: string) {\n    if (!node.parentElement) {\n      return\n    }\n    node.removeAttribute(attrName);\n\n    const lambdaFn = lambda(attrValue);\n\n    this.__state.startRecordExpressionVars()\n\n    const vars = this.__state.stopRecordExpressionVars();\n    vars.forEach((v: string) => {\n      if (!this.varExpressionObj[v]) {\n        this.varExpressionObj[v] = new Set<EXPRESSION_ACTION>();\n      }\n      this.varExpressionObj[v].add(node);\n    });\n    const action = ((attrNode: VELEMENT, fn: CallableFunction, actAttrName: string) => {\n      const scope = this.getNodeCompileScope(attrNode);\n      // const result = lambdaFn({...this.__state, ...scope});\n      // const result = lambdaFn( Object.assign(this.__state, scope));\n      const result = fn( this.__state, scope);\n      attrNode.setAttribute(actAttrName, result)\n    }).bind(null, node, lambdaFn, attrName.substring(1));\n    if (!this.expressionNodeMap.get(node)) {\n      this.expressionNodeMap.set(node, new Set())\n    }\n    this.expressionNodeMap.get(node).add(action)\n    action();\n  }\n\n\n\n\n  bindNodeExpression(node: VELEMENT, exp: VAR_AND_EXPRESSION, action: CallableFunction) {\n    let lambdaFn: CallableFunction = () => {}\n    if (exp.runtimeFn) {\n      lambdaFn = exp.runtimeFn\n    } else {\n      lambdaFn = lambda(exp.expression)\n    }\n\n\n\n    exp.vars.forEach((v: string) => {\n      if (!Object.prototype.hasOwnProperty.call(this.__state, v)) {\n        return;\n      }\n      if (typeof this.__state[v] == 'function') {\n        return\n      }\n      this.bindVarToNode(v, node)\n    });\n    const compileVar = () => {\n      if (!node.parentNode) {\n        return\n      }\n      const scope = this.getNodeCompileScope(node);\n      let result = null\n      if (exp.monitState) {\n        this.__state.startRecordExpressionVars();\n        result = lambdaFn(this.__state, this.sourceRef, scope);\n        const vars = this.__state.stopRecordExpressionVars();\n        vars.forEach((v: string) => {\n          this.bindVarToNode(v, node);\n        });\n      } else {\n        result = lambdaFn(this.__state, this.sourceRef,  scope);\n      }\n\n      return result\n    }\n\n    const actor: ACTOR =  ((result :string) => {\n      if (!result) {\n        const scope = this.getNodeCompileScope(node);\n        // const fnStr = lambdaFn.toString().slice(275)\n        // console.log(fnStr)\n        result = lambdaFn( this.__state, this.sourceRef, scope)\n      }\n      action(result)\n      // node.textContent = result;\n    });\n\n    exp.vars.forEach((v: string) => {\n      if (!Object.prototype.hasOwnProperty.call(this.__state, v)) {\n        return;\n      }\n      if (typeof this.__state[v] == 'function') {\n        this.doBindNodeToActor(node, actor)\n      } else {\n        this.doBindVarToActor(v, actor)\n      }\n    });\n    this.bindNodeActor(node, actor, compileVar);\n  }\n\n  doBindVarToActor(varName: string, actor: ACTOR) {\n    if (!this.varBindActorsMap[varName]) {\n      this.varBindActorsMap[varName] = new Set<ACTOR>();\n    }\n    this.varBindActorsMap[varName].add(actor)\n    fastdom.mutate(() => {\n      actor()\n    })\n  }\n\n  doBindNodeToActor(node: VELEMENT, actor: ACTOR) {\n    this.fnNodesSet.add(node);\n    if (!this.nodeBindActorsMap.get(node)) {\n      this.nodeBindActorsMap.set(node, new Set<ACTOR>());\n    }\n    this.nodeBindActorsMap.get(node).add(actor)\n    fastdom.mutate(() => {\n      actor()\n    })\n  }\n\n  bindNodeLoop(node: VELEMENT, loopVarName: string, bindVar: string, eachKey = '') {\n    const begin = document.createComment(`each ${bindVar} of ${loopVarName}`)\n    const end = document.createComment(`end each`)\n    node.parentNode.insertBefore(begin, node)\n    node.parentNode.insertBefore(end, node.nextSibling)\n\n    this.cacheLoopTagDomFragment.appendChild(node)\n    if (typeof this.__state[loopVarName] !== 'function') {\n\n      this.bindVarToNode(loopVarName, node)\n    }\n    const exp: VAR_AND_EXPRESSION = {\n      expression: `${loopVarName}`,\n      vars: new Set([loopVarName]),\n      // TODO loop 里的这个应该是返回操作,例如,del => 0,1 append 4, 5, and 2, 3 no change\n      // runtimeFn: () => {}\n    }\n    // const lambdaFn = lambda(exp.expression)\n    const patchItems = (old_blocks: any[], list: any[], keyName: string, bindVar:string) => {\n      // const nodeCompileContext = this.compileContentNodeMap.get(next);\n      // old_list.push(nodeCompileContext[bindVar].item)\n      let o = old_blocks.length;\n      let n = list.length;\n      const old_indexes:{[key: string]: any} = {}\n      let i = o;\n      const lookup = new Map()\n      while (i--) {\n        const nodeCompileContext = this.compileContentNodeMap.get(old_blocks[i]);\n        const k = nodeCompileContext[bindVar]['item'][keyName]\n        old_indexes[k] = i;\n        lookup.set(k, old_blocks[i])\n      }\n      console.log('old_indexes', old_indexes)\n\n      // const lookup = new Map()\n      // old_blocks.forEach(b => {\n      //   // lookup.set(b[key], new Node(b.key))\n      //   lookup.set(b[keyName], b)\n      // })\n\n      const new_blocks = [];\n      const new_lookup = new Map();\n      const deltas = new Map();\n      i = n\n      while (i--) {\n        const key = list[i][keyName];\n        let block = lookup.get(key);\n        // 这个block 应该对节点操作了?\n        if (!block) { // 新node, create it\n          // block = create_each_block(key, child_ctx);\n          // block.c();\n          // console.log('create', key);\n          block = node.cloneNode(true) as VELEMENT;\n          block.___uniqueItemKey = key;\n          block['detach'] = () => {\n            const varNames = this.nodeBindVarObj.get(block)\n            varNames.forEach(v => {\n              const iterSet = this.varBindNodeObj[v]\n              iterSet.forEach((el: any, ref: WeakRef<any>) => {\n                if (el === block) {\n                  iterSet.deleteByRef(ref)\n                }\n              })\n            })\n            this.nodeActorsMap.delete(block)\n          }\n          // block = new Node(key)\n        } else { // is old, only update it\n          // block.p(child_ctx, dirty);\n          // block.update(key)\n          console.log('update', key);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n          deltas.set(key, Math.abs(i - old_indexes[key]));\n      }\n      let next: any = end;\n      const will_move = new Set();\n      const did_move = new Set();\n\n      const destroy = (block: VELEMENT, lookup: Map<any, any>) => {\n        // const nodeCompileContext = this.compileContentNodeMap.get(block);\n        // const k = nodeCompileContext[bindVar]['item'][keyName]\n        lookup.delete(block.___uniqueItemKey);\n        block.remove()\n        block.detach()\n        console.log('destory', block, lookup )\n      }\n      const insert = (block: VELEMENT) => {\n\n        // console.log('insert', next? 'prev' : 'append', block)\n        lookup.set(block.___uniqueItemKey, block);\n        if (next) {\n          end.parentNode.insertBefore(block, next);\n        } else {\n          end.parentNode.appendChild(block);\n        }\n        const item = list[n-1]\n        const index = n;\n        const nodeCompileContext = this.compileContentNodeMap.get(block);\n        this.compileContentNodeMap.set(block, {\n          ...nodeCompileContext,\n          [bindVar]: {\n            item, index, key: block.___uniqueItemKey\n          },\n        });\n        compileWalker(block as VELEMENT, this.compile)\n        next = block;\n        n--;\n      }\n\n      while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.id;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n          next = new_block.first;\n          o--;\n          n--;\n        } else if (!new_lookup.has(old_key)) {\n          // remove old block\n          destroy(old_block, lookup);\n\n          o--;\n        } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n          insert(new_block);\n        } else if (did_move.has(old_key)) {\n          o--;\n        } else if (deltas.get(new_key) > deltas.get(old_key)) {\n          did_move.add(new_key);\n          insert(new_block);\n        } else {\n          will_move.add(old_key);\n          o--;\n        }\n      }\n      while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block[keyName])) {\n          destroy(old_block, lookup);\n\n        }\n      }\n      while (n) {\n        insert(new_blocks[n - 1]);\n      }\n      return new_blocks\n    }\n\n\n\n    this.bindNodeExpression(node, exp, (result: any) => {\n      let originResult = node.___bind_meta;console.log(exp)\n\n      if (!originResult||!Array.isArray(originResult)) {\n        originResult = [];\n      }\n      const old_list = [];\n      let start = begin.nextSibling;\n      while(start && start != end) {\n        const next = start.nextSibling;\n\n        // const nodeCompileContext = this.compileContentNodeMap.get(next);\n        // old_list.push(nodeCompileContext[bindVar].item)\n        old_list.push(start)\n        start = next;\n      }\n      patchItems(old_list, result, eachKey, bindVar);\n      node.___bind_meta = result;\n      return\n      // TODO use item key only change special changed item\n      start = begin.nextSibling;\n      // while(start && start != end) {\n      //   const next = start.nextSibling;\n      //   void (start as HTMLElement).remove();\n      //   start = next;\n      // }\n\n      (result as unknown as Array<any>).forEach((item: any, index: number) => {\n        const renderForNode = node.cloneNode(true) as VELEMENT;\n        this.gcRegistry.register(renderForNode, `renderForNode-${item.id}-${index}`);\n        const eachItemKey = eachKey? item[eachKey] : undefined;\n        if (eachItemKey && (start as VELEMENT).___uniqueItemKey === eachItemKey ) {\n          return\n        }\n        const nodeCompileContext = this.compileContentNodeMap.get(renderForNode);\n        renderForNode.___uniqueItemKey = eachKey? item[eachKey] : '';\n\n        this.compileContentNodeMap.set(renderForNode, {\n          ...nodeCompileContext,\n          [bindVar]: {\n            item, index, key: eachItemKey\n          },\n        });\n\n        if (start && start != end) {  // 有就替换\n          const next = start.nextSibling;\n          start.replaceWith(renderForNode)\n          start = next;\n        } else {  // 没有就插入\n          end.parentNode.insertBefore(renderForNode, end);\n        }\n        compileWalker(renderForNode as VELEMENT, this.compile)\n      });\n      while(start && start != end) { // 多余的删除\n        const next = start.nextSibling;\n        void (start as HTMLElement).remove();\n        start = next;\n      }\n    })\n    return\n\n\n\n\n\n\n\n  }\n\n  bindNodeProp(node: VELEMENT, propName: string, valueExp: string) {\n    const prop = propName.substring(1)\n    node.removeAttribute(propName);\n    node.addEventListener('input', (e) => {\n      // this.__state[valueExp] = node[prop]\n      const paths = valueExp.split('.')\n      let target = this.sourceRef;\n      const final = paths.pop();\n      while(paths.length) {\n        const p = paths.shift()\n        target = target[p]\n      }\n      const nodeType = node.type;\n      const asType = nodeType.charAt(0).toUpperCase() + nodeType.slice(1);\n      let valProp = `${prop}As${asType}`;\n      if(typeof node[valProp] == 'undefined') {\n        valProp = prop\n      }\n      target[final] = node[valProp]\n    });\n    this.bindNodeExpression(node, {\n      expression: valueExp,\n      vars: new Set([valueExp])\n    }, (result: string) => {\n      // const asType = result.charAt(0).toUpperCase() + result.slice(1);\n      // if (prop == 'value') {\n      //   const testProp = `valueAs${asType}`;\n      // }\n      node[prop] = result\n    });\n  }\n\n\n\n\n  bindStateFunction(fn: () => void) {\n    return (function() {\n      return eval(fn.toString());\n    }).call(this.__state)\n  }\n  bindNodeActor(node: VELEMENT|Text, actor: ACTOR, compileVar: CallableFunction) {\n    if (!this.nodeActorsMap.get(node)) {\n      this.nodeActorsMap.set(node, new Set<ACTOR>())\n      // this.nodeActorsMap.set(node, new IterableWeakSet<ACTOR>())\n    }\n    this.gcRegistry.register(actor, \"gc actor fn\");\n    this.nodeActorsMap.get(node).add(actor);\n    fastdom.measure(() => {\n      const result = compileVar()\n      fastdom.mutate(() => {\n        actor(result);\n      })\n    })\n    // this.compileVarQueue.add(compileVar)\n    // if (!this.compileVarNodes.get(node)) {\n    //   this.compileVarNodes.set(node, new WeakSet())\n    // }\n    // this.compileVarNodes.get(node).add(compileVar)\n  }\n  expandShorthandAttributes(node: VELEMENT) {\n    const attrs = node.getAttributeNames();\n    for (let i = 0; i < attrs.length; i++) {\n      const attr = node.getAttributeNode(attrs[i])\n      let attrName = attr.name as unknown as string;\n      let attrValue = attr.value as unknown as string;\n      const isShorthand =  EXPRESSION_REGEX.exec(attrName)\n      EXPRESSION_REGEX.lastIndex = 0; // reset pos\n      if (isShorthand) {\n        node.removeAttribute(attrName);\n        attrName = isShorthand[1];\n        if (attrName.trim().startsWith('...')) {\n          const propsName = attrName.trim().replace('...', '');\n          const propsObj = this.sourceRef[propsName];\n          if (this.sourceRef[propsName]) {\n            const propsKeys =Object.keys(propsObj)\n            for (let j = 0; j < propsKeys.length; j++) {\n              const pk = propsKeys[j]\n              attrValue = `{${propsName}.${pk}}`\n              node.setAttribute(pk, attrValue)\n            }\n\n          }\n        } else {\n          attrValue = `{${attrName}}`\n          node.setAttribute(attrName, attrValue)\n        }\n\n      }\n    }\n  }\n  isTrigger(attrName: string) {\n    return attrName.startsWith('@')\n  }\n  compile = (node: VELEMENT): LOOP_CONDITION_STATEMENT => {\n    if (node.nodeName == 'SCRIPT') {\n      return;\n    }\n    if (node.nodeType === COMMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) { // comment & DOCUMENT_FRAGMENT_NODE\n      return ;\n    }\n\n    if (node.nodeType === TEXT_NODE) {\n      const txtNode = (node as unknown as Text);\n      if (txtNode.wholeText.trim()) {\n        const textNodes = [];\n        const expressionStr = txtNode.wholeText;\n        const vars = extractVarsV2(expressionStr);\n        if (vars.length) {\n          let s = 0;\n          while(vars.length) {\n            const {varName, expName, start, end} = vars.shift();\n            let t = expressionStr.substring(s, start);\n            // console.log(expName, start, end);\n            const vv = extractVarsFromObject(this.__state, expName)\n            textNodes.push(document.createTextNode(t) );\n            t = expName\n            if (typeof this.__state[varName] === 'function') {\n              // const p1 = varName.indexOf('{')\n              // const p2 =varName.lastIndexOf('}')\n              // varName = varName.substring(p1 + 1, p2)\n              t = `{${varName}()}`\n            }\n            let tn: any = null;\n            let isHtmlNode = false;\n            if (expName.startsWith('{!')) {\n              isHtmlNode = true;\n              tn = document.createComment('')\n              const holderForReplace = document.createComment('')\n              textNodes.push(holderForReplace)\n              t = t.replace('{!', '{');\n            } else {\n              tn = document.createTextNode(t)\n            }\n\n            this.bindNodeExpression(tn as unknown as VELEMENT, {\n              expression: \"`$\" + t + \"`\",\n              vars: new Set([varName, ...vv])\n            } , (result: any) => {\n              if (isHtmlNode) {\n                tn.previousSibling.replaceWith(document.createRange().createContextualFragment(result));\n              } else {\n                tn.textContent = result;\n              }\n            })\n            textNodes.push(tn)\n            s = end\n          }\n          if (s < expressionStr.length) {\n            const t = expressionStr.substring(s)\n            textNodes.push(document.createTextNode(t))\n          }\n          txtNode.replaceWith(...textNodes)\n        }\n\n      }\n      // text node stop here\n      return LOOP_CONDITION_STATEMENT.CONTINUE;\n    }\n\n    this.expandShorthandAttributes(node);\n    const attrs = node.getAttributeNames()\n    const eachVarName = attrs.find((attr) => {\n       return attr.startsWith(':each-')\n     });\n\n     const isLoopNode = Boolean(eachVarName);\n\n\n     if (isLoopNode) {\n       if (eachVarName.startsWith(':each-')) { // each expression\n         const keyAttr = node.getAttribute(':each-key')\n         if (!keyAttr) {\n           throw new Error('each expression need key')\n         }\n        node.removeAttribute(':each-key')\n\n         const attrValue = node.getAttribute(eachVarName)\n         // console.log('[each]', eachVarName, attrValue);\n         let loopVar = toCamel(eachVarName.replace(':each-', '')  )\n         let bindVar = attrValue\n         // const eachPlaceHolder = document.createComment(`each ${attrValue } of ${loopVar}`) as unknown as VELEMENT\n         // node.parentNode.insertBefore(eachPlaceHolder, node.nextSibling)\n         node.removeAttribute(eachVarName)\n         const loopItemVars = extractVarsV2(loopVar)\n         if (loopItemVars[0]) {\n           const { varName } = loopItemVars[0];\n           loopVar = varName\n           // console.log('[each] [loopVar]', loopVar)\n         }\n         const eachItemVars = extractVarsV2(attrValue)\n         if (eachItemVars[0]) {\n           const { varName } = eachItemVars[0];\n           bindVar = varName\n           // console.log('[each] [bindVar]', bindVar)\n         }\n         let loopExpression = loopVar;\n         if (typeof this.__state[loopVar] === 'function') { // 是方法的话应该按attribute原样显示\n           loopExpression = `${loopVar}()`\n         }\n         this.bindNodeLoop(node, loopVar, bindVar, keyAttr);\n         return LOOP_CONDITION_STATEMENT.CONTINUE;\n       }\n\n     }\n\n    // console.log('attrs', node, attrs);\n    for (let i = 0; i < attrs.length; i++) {\n      const attr = node.getAttributeNode(attrs[i])\n      const attrName = attr.name as unknown as string;\n      const attrValue = attr.value as unknown as string;\n\n      if (attrName.startsWith(':if-')) { // if expression\n        // console.log('[if]', attrName, attrValue);\n        const ifPlaceHolder = document.createComment(`if ${attrName}==${attrValue}`) as unknown as VELEMENT\n        // node.parentNode.insertBefore(ifPlaceHolder, node)\n        node.parentNode.insertBefore(ifPlaceHolder, node.nextSibling)\n        node.removeAttribute(attrName)\n        const vars = extractVarsV2(attrValue)\n        if (vars[0]) { // should only one\n          let { varName } = vars[0];\n          let vv: string[] = [];\n          if (typeof this.__state[varName] === 'function') {\n            varName = `${varName}()`\n          } else {\n            vv = extractVarsFromObject(this.__state, varName)\n          }\n          const conditionExpr = `${attrName.substring(4)} === ${varName}`\n\n          this.bindNodeExpression(node as unknown as VELEMENT, {\n            expression: conditionExpr,\n            vars: new Set(vv)\n          } , (result: any) => {\n            if (!result) {\n              this.removeNode(node);\n            } else {\n              this.restoreRemoveNode(node);\n            }\n          })\n        }\n        continue\n      }\n\n      if (attrName.startsWith('.')) {\n        console.log('[prop]', attrName, attrValue);\n        const vars = extractVarsV2(attrValue)\n        if (vars[0]) { // should only one\n          this.bindNodeProp(node, attrName, vars[0].varName );\n        }\n        continue\n      }\n\n\n      const attrVars = this.isTrigger(attrName) ? [] : extractVarsV2(attrValue);\n      if (attrVars.length) {\n        const vars: Set<string> = new Set([]);\n        // console.log('attrValue', attrValue)\n        let attrStr = attrValue;\n        attrVars.forEach((v) => {\n          // console.log(v)\n          const extVars = extractVarsFromObject(this.__state, v.varName);\n          extVars.forEach(ev=> {\n            let varName = ev;\n            const attrVar = this.__state[ev]\n            if (typeof attrVar === 'undefined') {\n              return\n            }\n\n            if (typeof attrVar === 'function') {\n              varName = `${ev}()`\n            //   // varName = `{'${v.varName}'}` // 方法名\n            //   // node.removeAttribute(attrName)\n            //   return\n            }\n            // const re = new RegExp(v.expName, 'g')\n            // attrStr = attrStr.replace(re, \"${\" + varName + \"}\");\n            attrStr = replaceAllWithoutRegex(attrStr, v.expName, \"${\" + varName + \"}\" )\n            // attrStr = attrStr.replaceAll(v.expName, \"$\" + varName + \"\");\n            vars.add(ev)\n          })\n\n        })\n        // console.log(attrStr)\n        if (vars.size) {\n          this.bindNodeExpression(node as unknown as VELEMENT, {\n            expression: \"`\" + attrStr + \"`\",\n            vars\n          }, (result: any) => {\n            // console.log(node, attrName, result)\n            node.setAttribute(attrName, result);\n          });\n        }\n\n      }\n\n      if (attrName.startsWith('@')) {\n        node.removeAttribute(attrName)\n        const eventName = attrName.substring(1);\n        console.log('[event]', attrName, attrValue);\n        const callbacks = extractVarsV2(attrValue);\n        let callback = attrValue;\n        if (callbacks && callbacks.length) {\n          for (let j = 0; j < callbacks.length; j++) {\n            const cb = callbacks[j];\n            let cbName: any = cb;\n            if (cb && cb.varName) {\n              cbName = cb.varName\n            }\n            if (this.sourceRef[cbName] ) {\n              callback = cbName\n            }\n          }\n        }\n        console.log('callback', callback)\n        node.addEventListener(eventName, (evt) => {\n          // this.__state[attrValue](evt)\n          fastdom.mutate(() => {\n            this.sourceRef[callback](evt)\n          })\n        })\n      }\n    }\n  }\n\n\n\n\n  disconnectedCallback() {\n    // browser calls this method when the element is removed from the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  static get observedAttributes(): string[]  {\n    return [/* array of attribute names to monitor for changes */];\n  }\n\n  attributeChangedCallback(name: string, oldValue: string, newValue: string) {\n    // called when one of attributes listed above is modified\n  }\n\n  adoptedCallback() {\n    // called when the element is moved to a new document\n    // (happens in document.adoptNode, very rarely used)\n  }\n\n  // there can be other element methods and properties\n}\n\ncustomElements.define(\"ez-widget\", EzWidget);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(952);\n"],"names":["fd","win","raf","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","FastDom","self","this","reads","writes","bind","scheduleFlush","fastdom","scheduled","flush","error","length","runTasks","e","message","catch","remove","array","item","index","indexOf","splice","prototype","constructor","tasks","task","shift","measure","fn","ctx","push","mutate","clear","extend","props","Error","child","Object","create","target","source","key","hasOwnProperty","mixin","initialize","window","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","COMMENT_NODE","randomLocalsScopeName","Date","now","randomSourceScopeName","IS_PROXY","Symbol","PARENT_PATH","LOOP_CONDITION_STATEMENT","EXPRESSION_REGEX","DOM_RENDER_ACTION_TYPE","___IterableWeakSet","Set","add","el","ref","super","values","deref","WeakRef","forEach","value","delete","iterator","IterableWeakSet","__set","deleteByValue","deleteByRef","IterableWeakMap","keysSet","valueStore","WeakMap","k","v","get","has","set","ActorRefRunCounter","__actorRunCounter","act","val","reset","DirtyableValue","pathKey","_dirty","_pathKey","_value","static","includes","isDirty","toString","valueOf","isReflectable","Array","isArray","toCamel","s","replace","$1","toUpperCase","___lambda","exp","node","Proxy","prop","receiver","console","log","Reflect","Function","call","lambda","cache","stylesheet","CSSStyleSheet","slice","treeWalker","compile","nodeType","curChild","firstChild","nextSibling","walk","nodes","check","normalize","ret","CONTINUE","BREAK","RETURN","childNodes","concat","compileWalker","watchDom","fragment","mutationRecords","observer","MutationObserver","mutationsList","observe","childList","subtree","attributes","attributeOldValue","characterDataOldValue","characterData","takeRecords","MutationRecord","disconnect","subStrAtPos","tpl","step","pos","f","i","join","extractVarsV2","template","openChar","closeChar","ol","cl","tl","data","sq","dq","substring","j","pop","start","end","expName","trim","varName","replaceAllWithoutRegex","oldStr","newStr","fromLen","output","matchPos","extractVarsFromObject","obj","str","ks","keys","filter","name","re","RegExp","match","bindFunctionScope","eval","StateHandle","p","recordExpressionVars","WeakSet","result","parent","String","newVal","StateProxy","deleteProperty","getOwnPropertyDescriptor","undefined","enumerable","configurable","writable","ownKeys","loopNestedObj","entries","EzWidget","HTMLElement","__state","varExpressionObj","expressionNodeMap","nodePositionMap","compileContentNodeMap","nodeActorsMap","varBindNodeObj","nodeBindVarObj","varBindActorsMap","nodeBindActorsMap","fnNodesSet","actorRefCounter","nodeName","txtNode","wholeText","textNodes","expressionStr","vars","t","vv","document","createTextNode","tn","isHtmlNode","startsWith","createComment","holderForReplace","bindNodeExpression","expression","previousSibling","replaceWith","createRange","createContextualFragment","textContent","expandShorthandAttributes","attrs","getAttributeNames","eachVarName","find","attr","Boolean","keyAttr","getAttribute","removeAttribute","attrValue","loopVar","bindVar","loopItemVars","eachItemVars","loopExpression","bindNodeLoop","getAttributeNode","attrName","ifPlaceHolder","parentNode","insertBefore","conditionExpr","restoreRemoveNode","removeNode","bindNodeProp","attrVars","isTrigger","attrStr","ev","attrVar","size","setAttribute","eventName","callbacks","callback","cbName","sourceRef","addEventListener","evt","shadow","attachShadow","mode","adoptedStyleSheets","innerHTML","gcRegistry","FinalizationRegistry","heldValue","connectedCallback","cssRules","cacheIfTagDomFragment","createDocumentFragment","cacheLoopTagDomFragment","dispatchEvent","CustomEvent","bubbles","detail","render","getInternalKey","makeStateReflectable","state","root","internalKey","defineProperty","actors","runActors","setState","next","prev","parentElement","appendChild","info","getNodeCompileScope","parentScope","nodeScope","bindVarToNode","bindNodePropAction","lambdaFn","startRecordExpressionVars","stopRecordExpressionVars","action","attrNode","actAttrName","scope","runtimeFn","actor","doBindNodeToActor","doBindVarToActor","bindNodeActor","monitState","loopVarName","eachKey","begin","patchItems","old_blocks","list","keyName","o","n","old_indexes","lookup","Map","new_blocks","new_lookup","deltas","block","cloneNode","___uniqueItemKey","iterSet","Math","abs","will_move","did_move","destroy","detach","insert","nodeCompileContext","new_block","old_block","new_key","id","old_key","first","originResult","___bind_meta","old_list","propName","valueExp","paths","split","final","type","asType","charAt","valProp","bindStateFunction","compileVar","register","isShorthand","exec","lastIndex","propsName","propsObj","propsKeys","pk","disconnectedCallback","observedAttributes","attributeChangedCallback","oldValue","newValue","adoptedCallback","customElements","define","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__"],"sourceRoot":""}