{"version":3,"file":"ez-widget.js","mappings":"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","sources":["webpack://ez-web-components/./src/components/ez-widget/fastdom.js","webpack://ez-web-components/webpack/bootstrap","webpack://ez-web-components/webpack/runtime/make namespace object","webpack://ez-web-components/./src/components/ez-widget/index.ts"],"sourcesContent":["!(function(win) {\n\n  /**\n   * FastDom\n   *\n   * Eliminates layout thrashing\n   * by batching DOM read/write\n   * interactions.\n   *\n   * @author Wilson Page <wilsonpage@me.com>\n   * @author Kornel Lesinski <kornel.lesinski@ft.com>\n   */\n\n  'use strict';\n\n  /**\n   * Mini logger\n   *\n   * @return {Function}\n   */\n  var debug = 0 ? console.log.bind(console, '[fastdom]') : function() {};\n\n  /**\n   * Normalized rAF\n   *\n   * @type {Function}\n   */\n  var raf = win.requestAnimationFrame\n      || win.webkitRequestAnimationFrame\n      || win.mozRequestAnimationFrame\n      || win.msRequestAnimationFrame\n      || function(cb) { return setTimeout(cb, 16); };\n\n  /**\n   * Initialize a `FastDom`.\n   *\n   * @constructor\n   */\n  function FastDom() {\n    var self = this;\n    self.reads = [];\n    self.writes = [];\n    self.raf = raf.bind(win); // test hook\n    debug('initialized', self);\n  }\n\n  FastDom.prototype = {\n    constructor: FastDom,\n\n    /**\n     * We run this inside a try catch\n     * so that if any jobs error, we\n     * are able to recover and continue\n     * to flush the batch until it's empty.\n     *\n     * @param {Array} tasks\n     */\n    runTasks: function(tasks) {\n      debug('run tasks');\n      var task; while (task = tasks.shift()) task();\n    },\n\n    /**\n     * Adds a job to the read batch and\n     * schedules a new frame if need be.\n     *\n     * @param  {Function} fn\n     * @param  {Object} ctx the context to be bound to `fn` (optional).\n     * @public\n     */\n    measure: function(fn, ctx) {\n      debug('measure');\n      var task = !ctx ? fn : fn.bind(ctx);\n      this.reads.push(task);\n      scheduleFlush(this);\n      return task;\n    },\n\n    /**\n     * Adds a job to the\n     * write batch and schedules\n     * a new frame if need be.\n     *\n     * @param  {Function} fn\n     * @param  {Object} ctx the context to be bound to `fn` (optional).\n     * @public\n     */\n    mutate: function(fn, ctx) {\n      debug('mutate');\n      var task = !ctx ? fn : fn.bind(ctx);\n      this.writes.push(task);\n      scheduleFlush(this);\n      return task;\n    },\n\n    /**\n     * Clears a scheduled 'read' or 'write' task.\n     *\n     * @param {Object} task\n     * @return {Boolean} success\n     * @public\n     */\n    clear: function(task) {\n      debug('clear', task);\n      return remove(this.reads, task) || remove(this.writes, task);\n    },\n\n    /**\n     * Extend this FastDom with some\n     * custom functionality.\n     *\n     * Because fastdom must *always* be a\n     * singleton, we're actually extending\n     * the fastdom instance. This means tasks\n     * scheduled by an extension still enter\n     * fastdom's global task queue.\n     *\n     * The 'super' instance can be accessed\n     * from `this.fastdom`.\n     *\n     * @example\n     *\n     * var myFastdom = fastdom.extend({\n     *   initialize: function() {\n     *     // runs on creation\n     *   },\n     *\n     *   // override a method\n     *   measure: function(fn) {\n     *     // do extra stuff ...\n     *\n     *     // then call the original\n     *     return this.fastdom.measure(fn);\n     *   },\n     *\n     *   ...\n     * });\n     *\n     * @param  {Object} props  properties to mixin\n     * @return {FastDom}\n     */\n    extend: function(props) {\n      debug('extend', props);\n      if (typeof props != 'object') throw new Error('expected object');\n\n      var child = Object.create(this);\n      mixin(child, props);\n      child.fastdom = this;\n\n      // run optional creation hook\n      if (child.initialize) child.initialize();\n\n      return child;\n    },\n\n    // override this with a function\n    // to prevent Errors in console\n    // when tasks throw\n    catch: null\n  };\n\n  /**\n   * Schedules a new read/write\n   * batch if one isn't pending.\n   *\n   * @private\n   */\n  function scheduleFlush(fastdom) {\n    if (!fastdom.scheduled) {\n      fastdom.scheduled = true;\n      fastdom.raf(flush.bind(null, fastdom));\n      debug('flush scheduled');\n    }\n  }\n\n  /**\n   * Runs queued `read` and `write` tasks.\n   *\n   * Errors are caught and thrown by default.\n   * If a `.catch` function has been defined\n   * it is called instead.\n   *\n   * @private\n   */\n  function flush(fastdom) {\n    debug('flush');\n\n    var writes = fastdom.writes;\n    var reads = fastdom.reads;\n    var error;\n\n    try {\n      debug('flushing reads', reads.length);\n      fastdom.runTasks(reads);\n      debug('flushing writes', writes.length);\n      fastdom.runTasks(writes);\n    } catch (e) { error = e; }\n\n    fastdom.scheduled = false;\n\n    // If the batch errored we may still have tasks queued\n    if (reads.length || writes.length) scheduleFlush(fastdom);\n\n    if (error) {\n      debug('task errored', error.message);\n      if (fastdom.catch) fastdom.catch(error);\n      else throw error;\n    }\n  }\n\n  /**\n   * Remove an item from an Array.\n   *\n   * @param  {Array} array\n   * @param  {*} item\n   * @return {Boolean}\n   */\n  function remove(array, item) {\n    var index = array.indexOf(item);\n    return !!~index && !!array.splice(index, 1);\n  }\n\n  /**\n   * Mixin own properties of source\n   * object into the target.\n   *\n   * @param  {Object} target\n   * @param  {Object} source\n   */\n  function mixin(target, source) {\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) target[key] = source[key];\n    }\n  }\n\n// There should never be more than\n// one instance of `FastDom` in an app\n  const exports = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line\n  // export const fd = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line\n// Expose to CJS & AMD\n  if ((typeof define) == 'function') define(function() { return exports; });\n  else if ((typeof module) == 'object') module.exports = exports;\n\n})( typeof window !== 'undefined' ? window : this);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as style from \"./style.less\"\n// import * as fastdom from './fastdom';\nconst fastdom = require('./fastdom')\n// import  './fastdom';\n\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst randomLocalsScopeName = `___$locals$___${Date.now()}`\nconst IS_PROXY = Symbol(\"IS_PROXY\")\nconst PARENT_PATH = Symbol(\"PARENT_PATH\")\n\n// https://gist.github.com/seanlinsley/bc10378fd311d75cf6b5e80394be813d\nclass ___IterableWeakSet<T> extends Set {\n  add(el: any) {\n    for (const ref of super.values()) {\n      const value = ref.deref()\n      if (value == el) {\n        return this\n      }\n    }\n    // const ref = new WeakRef(el);\n    super.add(new WeakRef(el))\n    return this\n  }\n\n  forEach(fn: CallableFunction) {\n    super.forEach((ref, index) => {\n      const value = ref.deref()\n      if (value) {fn(value, ref)} else {\n        super.delete(ref)\n      }\n    })\n  }\n  *[Symbol.iterator]() {\n    for (const ref of super.values()) {\n      const value = ref.deref()\n      if (value) yield value\n    }\n  }\n}\nclass IterableWeakSet<T> {\n  private __set: Set<any>;\n  constructor() {\n    this.__set = new Set();\n  }\n  deleteByValue(el: any) {\n    for (const ref of this.__set.values()) {\n      const value = ref.deref()\n      if (value == el) {\n        this.__set.delete(ref)\n      }\n    }\n  }\n  deleteByRef(ref: WeakRef<any>) {\n    this.__set.delete(ref)\n  }\n  add(el: any) {\n    for (const ref of this.__set.values()) {\n      const value = ref.deref()\n      if (value == el) {\n        return ref\n      }\n    }\n    const ref = new WeakRef(el);\n    this.__set.add(ref)\n    return ref\n  }\n\n  forEach(fn: CallableFunction) {\n    this.__set.forEach((ref) => {\n      const value = ref.deref()\n      if (value) {\n        fn(value, ref)\n      } else {\n        this.__set.delete(ref)\n      }\n    })\n  }\n  *[Symbol.iterator]() {\n    for (const ref of this.__set.values()) {\n      const value = ref.deref()\n      if (value) yield value\n    }\n  }\n}\n\n\ntype VAR_AND_EXPRESSION = {\n  expression: string;\n  vars: string[];\n  monitState?: boolean,\n  runtimeFn?: CallableFunction\n}\nenum LOOP_CONDITION_STATEMENT {\n  CONTINUE,\n  BREAK,\n  RETURN,\n  NOTHING\n}\nconst EXPRESSION_REGEX = /{([^{}]+?)}/g\n\nenum DOM_RENDER_ACTION_TYPE {\n  REPLACE,\n  REORDER,\n  ATTRS,\n  TEXT\n}\n\ntype ACTOR = (...args: any) => void|CallableFunction;\ntype iterableObj<T>= {\n  [key: string]: T,\n  // [Symbol.iterator]: T\n  // [Symbol.iterator]() : IterableIterator<any>;\n}\ntype VELEMENT  = (HTMLElement ) & {\n  detach: () => void;\n  ___bind_meta?: any;\n  ___uniqueItemKey?:string|symbol;\n  ___ez_compiled: boolean;\n  compileContext: iterableObj<any>} & {\n  [propName: string]: any;\n}\ntype EXPRESSION_ACTION = (...args: any) => void;\n\nclass DirtyableValue  {\n  private _value: any;\n  private _dirty= false;\n  private _pathKey = '';\n  static isPrimitiveValue(value: undefined |null |boolean | number | string | symbol): boolean {\n    if (value === null) {\n      return true;\n    }\n    const t = typeof value;\n    const primitiveTypes = ['undefined' , 'boolean', 'number', 'string', 'symbol']\n    return primitiveTypes.includes(t)\n  }\n  constructor(value: any, pathKey:string) {\n\n\n    this._value = value;\n    this._pathKey = pathKey;\n  }\n\n\n\n  get value() {\n    return this._value\n  }\n  set value (val: any){\n    this._dirty = true;\n    this._value = val;\n  }\n  get isDirty () {\n    return this._dirty;\n  }\n  reset() {\n    this._dirty = false;\n  }\n  toString () {\n    // return `<DirtyableValue>${this._value}`;\n    return this._value;\n  }\n  valueOf () {\n    return this._value;\n  }\n\n}\nfunction isReflectable(v: any) {\n  // FIXME to do with or without Array\n  return v != null && typeof v !== 'function' &&  !Array.isArray(v) && typeof v == 'object';\n  // return !(v != null &&  !Array.isArray(v) && typeof v !== 'function' && typeof v !== 'object');\n}\nconst toCamel = (s: string) => {\n  return s.replace(/([-_][a-z])/ig, ($1: string) => {\n    return $1.toUpperCase()\n      .replace('-', '')\n      .replace('_', '');\n  });\n};\n\n\n// https://stackoverflow.com/questions/543533/restricting-eval-to-a-narrow-scope\n// https://stackoverflow.com/questions/61552/are-there-legitimate-uses-for-javascripts-with-statement\nfunction ___lambda(exp: string,ctx={}, node:any=null) {\n  if (node) {\n    ctx = new Proxy(ctx,{\n      has:()=>true,\n      get: (target: any, prop: string, receiver) => {\n        console.log( prop, prop in target)\n        return Reflect.get(target, prop, receiver);\n      },\n    })\n  }\n\n  // execute script in private context\n  const func = (new Function( `with(this) {\n   try {\n    return ${exp};\n   } catch(e) {\n   }\n  }`));\n  return func.call(ctx);\n}\n\nconst lambda: CallableFunction = (function(){\n  const cache: {[key: string]: CallableFunction} = {};\n\n  function expressionTemplate(exp: string){\n    let fn = cache[exp];\n    if (!fn){\n      // fn =(new Function( 'ctx', `with(ctx) { try {return ${exp};} catch(r) {}}`));\n      // fn =(new Function( 'ctx', `with(ctx) { return ${exp};}`));\n      try{\n        fn = (new Function( `ctx, ${randomLocalsScopeName}`, `\n        if (!${randomLocalsScopeName} || !Object.keys(${randomLocalsScopeName}).length) {\n          ${randomLocalsScopeName} = {};\n        };\n        with(ctx) { \n          with(${randomLocalsScopeName}) { \n            return  ${exp};\n          }\n        }`))\n      } catch (e) {\n        throw new Error(`[Template Compile Error] SyntaxError:${e.message}`)\n      }\n      cache[exp] = fn;\n    }\n    return fn;\n  }\n  return expressionTemplate;\n})();\n\n\n\nconst stylesheet = new CSSStyleSheet();\nconst slice = Array.prototype.slice\n// const varNodeMap: {\n//   [key: string]: Set<VELEMENT>\n// } = {};\n// const varActionMap: {\n//   [key: string]: Set<any>\n// } = {};\n\n\n\n\nfunction treeWalker(node: HTMLElement|Node, compile: (n: VELEMENT) => void) {\n  if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    let curChild = node.firstChild;\n    while (curChild) {\n      // console.log('[nodeName]',curChild.nodeName)\n      compile(curChild as VELEMENT)\n      treeWalker(curChild, compile);\n      curChild = curChild.nextSibling;\n    }\n  }\n}\nfunction walk(nodes: Node|Node[]|NodeListOf<ChildNode>, check: (n: VELEMENT) => LOOP_CONDITION_STATEMENT) {\n  if (!('length' in nodes)) {\n    nodes = [nodes]\n  }\n\n  nodes = slice.call(nodes)\n\n  while((nodes as VELEMENT[]).length) {\n    const node = (nodes as  VELEMENT[]).shift()\n    node.normalize();\n    const ret = check(node)\n\n    if (ret === LOOP_CONDITION_STATEMENT.CONTINUE) {\n      continue\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.BREAK) {\n      break\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.RETURN) {\n      return\n    }\n\n    if (node.childNodes && node.childNodes.length) {\n      nodes = slice.call(node.childNodes).concat(nodes)\n    }\n  }\n}\nfunction compileWalker(nodes: Node|Node[]|NodeListOf<ChildNode>, compile: (n: VELEMENT) => LOOP_CONDITION_STATEMENT) {\n  if (!('length' in nodes)) {\n    nodes = [nodes]\n  }\n  nodes = slice.call(nodes)\n  while((nodes as VELEMENT[]).length) {\n    const node = (nodes as  VELEMENT[]).shift()\n    node.normalize();\n    const ret = compile(node)\n    if (ret === LOOP_CONDITION_STATEMENT.CONTINUE) {\n      continue\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.BREAK) {\n      break\n    }\n    if (ret === LOOP_CONDITION_STATEMENT.RETURN) {\n      return\n    }\n    if (node.childNodes && node.childNodes.length) {\n      nodes = slice.call(node.childNodes).concat(nodes)\n    }\n  }\n}\n\n// https://javascript.info/mutation-observer\nfunction watchDom(fragment: Node, check: (n: VELEMENT) => LOOP_CONDITION_STATEMENT) {\n  const mutationRecords = [];\n  const callback = function(mutationsList: MutationRecord[], observer: MutationObserver) {\n    console.log(mutationsList, observer );\n    // // Use traditional 'for loops' for IE 11\n    // for(const mutation of mutationsList) {\n    //   if (mutation.type === 'childList') {\n    //     console.log('A child node has been added or removed.');\n    //   }\n    //   else if (mutation.type === 'attributes') {\n    //     console.log('The ' + mutation.attributeName + ' attribute was modified.');\n    //   }\n    // }\n  };\n  const observer = new MutationObserver(callback);\n  // Start observing the target node for configured mutations\n  observer.observe(fragment, {\n    childList: true, // observe direct children\n    subtree: true, // and lower descendants too\n    attributes: true,\n    attributeOldValue: true,\n    characterDataOldValue: true, // pass old data to callback\n    characterData: true,\n  });\n\n  try{\n    walk(fragment.childNodes, check)\n  } catch(e) {\n    //\n  } finally {\n    // get a list of unprocessed mutations\n    // should be called before disconnecting,\n    // if you care about possibly unhandled recent mutations\n    const unhandledMutationRecords = observer.takeRecords();\n    unhandledMutationRecords.forEach(MutationRecord => mutationRecords.push(MutationRecord))\n    // Later, you can stop observing\n    observer.disconnect();\n  }\n}\nfunction subStrAtPos(tpl: string, step: number , pos: number) {\n  const f = []\n  for (let i = 0; i < step; i++) {\n    const s = tpl[pos + i]\n    if (s) {\n      f.push(s)\n    }\n  }\n  return f.join('')\n}\n\n\nfunction extractVarsV2(template: string, openChar = \"{\", closeChar = \"}\") {\n\n  let i = 0;\n  const ol = openChar.length;\n  const cl = closeChar.length;\n  const tl = template.length;\n  const data = [];\n  const sq = [];\n  const dq = [];\n  do {\n    if (template.substring(i, i+ol) == openChar) {\n      for (let j=i+1; j<=(tl - cl ); j++) {\n        if (template[j] === \"'\") {\n          sq.length & 1 ? sq.pop() : sq.push(null);\n        }\n\n        if (template[j] === '\"') {\n          dq.length & 1 ? dq.pop() : dq.push(null);\n        }\n        if(template.substring(j, j+ol) == openChar && !sq.length && !dq.length) {\n          i = j\n        }\n\n        if (template.substring(j, j+cl) == closeChar && ( !sq.length && !dq.length )  ) {\n          sq.length = 0;\n          dq.length = 0;\n          const start = i;\n          const end = j+cl;\n          data.push({\n            start,\n            end,\n            expName: template.slice(start, end).trim(),\n            varName: template.slice(start + ol, j).trim()\n          })\n          i = j+1;\n          break;\n        }\n      }\n    }\n  } while (++i <= (template.length - openChar.length ))\n\n  return data;\n}\nfunction extractVarsFromObject(obj: any, str: string) {\n  const ks = Object.keys(obj).filter(k => {\n    return typeof obj[k] != 'function' && typeof obj[k] != 'object'\n  })\n  // const re = new RegExp(`\\\\b(?:${ks.join('|')})\\\\b`.replaceAll('.', `\\\\.`), 'g')\n  const re = new RegExp(`\\\\b(?:${ks.join('|')})\\\\b`.replace(/\\./, `\\\\.`), 'g')\n  return str.match(re) || []\n}\n\n\n\nfunction bindFunctionScope(ctx: any, fn: () => void) {\n  return (function() {\n    return eval(fn.toString());\n  }).call(ctx);\n}\n\nconst StateHandle: ProxyHandler<any> = {\n  has:(target: any, p) => {\n    if (p === randomLocalsScopeName) {\n      return false;\n    }\n    return true;\n  },\n  get(target: any, prop: string|symbol, receiver) {\n    // console.log('get', target, prop)\n    if (prop === IS_PROXY) {\n      return true;\n    }\n    // if (prop === 'ctx') {\n    //   return receiver;\n    // }\n\n    if (prop === 'startRecordExpressionVars') {\n      this.recordExpressionVars = new WeakSet()\n      return () => {\n        //\n      };\n    }\n    if (prop === 'stopRecordExpressionVars') {\n      // TODO 如果一个函数内没执行到的块里的变量将记录不到, 咋处理?\n      // 除非返回全部state内变量, 或者通过编译,通过Acorn语法树提取变量\n      return () => {\n        const result = Object.keys(target);\n        // const result = Array.from(this.recordExpressionVars)\n        try{\n          return result;\n        } finally {\n          this.recordExpressionVars.clear();\n          delete this.recordExpressionVars;\n        }\n      }\n\n\n    }\n\n    // let value = target[prop];\n    // return (typeof value === 'function') ? value.bind(target) : value; // (*)\n\n    if (typeof prop != 'symbol' && Object.prototype.hasOwnProperty.call(target, prop)) {\n      if (this.recordExpressionVars) {\n        // const parent = Object.getOwnPropertyDescriptor(receiver, PARENT_PATH);\n        const parent = receiver[PARENT_PATH]\n        let varName = prop;\n        if (parent) {\n          varName = `${parent}.${String(prop)}`;\n        }\n        this.recordExpressionVars.add(varName);\n        console.log( '__state get', prop, prop in target)\n      }\n      // 引起循环调用，应该规避掉循环调用还是注释下面凑合\n      // if (typeof target[prop] === 'function') {\n        // if (this.recordExpressionVars) {\n        //   return target[prop].call(receiver);\n        // } else {\n        //   return target[prop]();\n        // }\n      // }\n\n    }\n    /*if (prop != Symbol.unscopables && String(prop).includes('.')) {\n      const props = String(prop).split('.');\n      const final = props.pop();\n      let layer = target;\n      let p = null;\n      for (let i = 0; i < props.length; i++) {\n        p = props[i];\n        if (typeof layer[p] === 'undefined') {\n          return undefined\n          // layer[p] =  new StateProxy({});\n        }\n        layer = layer[p]\n      }\n      return layer[final];\n    }*/\n    return Reflect.get(target, prop, receiver);\n  },\n  set(target: any, prop: string|symbol, val, receiver) { // to intercept property writing\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\n      // return true;\n      // throw new Error(`property ${String(prop)} has already been set`);\n    }\n    let newVal = val\n    if (isReflectable(val)) {\n      newVal = new StateProxy(val);\n    }\n    if (val && typeof val === 'function') {\n      // TODO should I make arrow function bind state?\n      // https://github.com/flycrum/check-is-arrow-function/blob/master/src/lib/checkIsArrowFunction.ts\n    }\n    // if (prop === 'objPath') {\n    //   return this.objPath.push(prop);\n    // }\n    // (receiver as any).WATCH_PATH = prop\n\n    /*if (prop != Symbol.unscopables && String(prop).includes('.')) {\n      const props = String(prop).split('.');\n      const final = props.pop()\n      let p = null;\n      const objPath = [];\n      for (let i = 0; i < props.length; i++) {\n        p = props[i];\n        objPath.push(p)\n        if (typeof target[p] === 'undefined') {\n          // If we're setting\n          if (typeof newVal !== 'undefined') {\n            // If we're not at the end of the props, keep adding new empty objects\n            if (i != props.length)\n              target[p] = {}; // new StateProxy({});\n              const pt = objPath.join('.');\n              Object.defineProperty(target[p],\n                PARENT_PATH,\n                {\n                  value: pt,\n                  configurable: false,\n                  enumerable: false,\n                  writable: false,\n                  });\n          }\n          else\n            return undefined;\n        }\n        target = target[p]\n      }\n      // target[final] = newVal;\n      return Reflect.set(target, final, newVal, receiver);\n    }*/\n    return Reflect.set(target, prop, newVal, receiver);\n  },\n  deleteProperty(target: any, prop: string) { // to intercept property deletion\n    // delete target[prop];\n    // return true;\n    return Reflect.deleteProperty(target, prop);\n  },\n  getOwnPropertyDescriptor(target, prop) {\n    let value = undefined;\n    /*if (prop != Symbol.unscopables && String(prop).includes('.')) {\n      const props = String(prop).split('.');\n      const final = props.pop();\n      let layer = target;\n      let p = null;\n      for (let i = 0; i < props.length; i++) {\n        p = props[i];\n        if (typeof layer[p] === 'undefined') {\n          return undefined\n        }\n        layer = layer[p]\n      }\n      value = layer[final];\n    } else {*/\n      value = Object.prototype.hasOwnProperty.call(target, prop)\n    // }\n    if (value && value != undefined) {\n      return {\n        value : value,\n        //use a logical set of descriptors:\n        enumerable : true,\n        configurable : true,\n        writable : true\n      };\n    }\n\n  },\n  ownKeys(target: any) { // to intercept property list\n    // return Object.keys(target).filter(key => !key.startsWith('_'));\n    return Reflect.ownKeys(target);\n  }\n\n}\n\n\n\n\nclass StateProxy<T> {\n  constructor(source: T) {\n    return new Proxy(source, StateHandle);\n  }\n}\n\n\n\nconst loopNestedObj = (obj: any) => {\n  Object.entries(obj).forEach(([key, val]) => {\n    if (isReflectable(val)) {\n      obj[key] = loopNestedObj(val);\n    } else { // or do something with key and val.\n      console.log(key, val);\n      //do nothing\n    }\n  });\n  return new StateProxy(obj)\n};\n\n\nexport class EzWidget extends HTMLElement {\n\n  private __state: Record<string, any> = new StateProxy<Record<string, any>>({});\n\n  private varExpressionObj: {[key: string]: Set<EXPRESSION_ACTION|Node>} = {};\n  private expressionNodeMap = new WeakMap();\n\n  private nodePositionMap = new WeakMap();\n  private compileContentNodeMap = new WeakMap();\n\n  public nodeActorsMap = new WeakMap<VELEMENT|Text, Set<ACTOR>>()\n  public varBindNodeObj: {[key: string]:  IterableWeakSet<any>} = {};\n  public nodeBindVarObj = new WeakMap<VELEMENT|Text, Set<string>>();\n\n\n  private cacheIfTagDomFragment: DocumentFragment;\n  private cacheLoopTagDomFragment: DocumentFragment;\n\n  // for internal change value\n  private sourceRef: any;\n  private gcRegistry: FinalizationRegistry<unknown>;\n\n  constructor() {\n    super();\n    console.log('constructor')\n    // element created\n    const shadow = this.attachShadow({ mode: 'open' });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    shadow.adoptedStyleSheets = [stylesheet];\n\n\n    shadow.innerHTML = `\n       <slot></slot>\n    `.replace(/[\\s\\n]*\\n[\\s\\n]*/g, '');\n\n    this.gcRegistry = new FinalizationRegistry(heldValue => {\n      console.log('gcRegistry', heldValue)\n      // ....\n    });\n  }\n\n  connectedCallback() {\n    // browser calls this method when the element is added to the document\n    // (can be called many times if an element is repeatedly added/removed)\n    // Only actually parse the stylesheet when the first instance is connected.\n    if (stylesheet.cssRules.length == 0) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      //   stylesheet.replaceSync(style.toString());\n    }\n\n\n    // const tmpl = document.querySelector('template');\n    // const dom = tmpl.content.cloneNode(true);\n\n    // const tmpl = this.shadowRoot.querySelector('slot');\n    // this.vdom = tmpl.cloneNode(true);\n\n    this.cacheIfTagDomFragment = document.createDocumentFragment();\n    this.cacheLoopTagDomFragment = document.createDocumentFragment();\n    /*this.originalDomFragment = document.createDocumentFragment();\n    // // this.calcDomFragment = document.createDocumentFragment();\n    while (false && this.childNodes.length) {\n      const n = this.childNodes[0];\n      if(n.nodeType == COMMENT_NODE\n        || n.nodeType == DOCUMENT_FRAGMENT_NODE\n        || n.nodeName == 'SCRIPT') {\n        n.remove()\n        continue;\n      }\n    //   console.log(n);\n      this.originalDomFragment.appendChild(n)\n    //   this.originalDomFragment.appendChild(n.cloneNode(true))\n    //   // this.calcDomFragment.appendChild(n);\n    }*/\n    this.dispatchEvent(new CustomEvent('created', {bubbles: true,detail: this}));\n    console.log(22222)\n    // walk(this.originalChildNodes.childNodes, (node) => {\n    //   this.rendererNodeMap.set(node, node.cloneNode())\n    //   this.calcChildNodes.appendChild(node)\n    //   return LOOP_CONDITION_STATEMENT.NOTHING\n    // })\n    // walk(this.originalDomFragment.childNodes, this.check)\n    compileWalker(this.childNodes, this.compile)\n    // walkTree(this, this.compile)\n    // walk(this.originalChildNodes.cloneNode(true), this.check)\n    // tmpl.remove()\n    // this.shadowRoot.append(dom);\n    this.dispatchEvent( new CustomEvent('mounted', {detail: this}));\n  }\n\n  render() {\n    //\n  }\n\n\n  getInternalKey(key: string) {\n    // return `__ez__|${key}`\n    return key\n  }\n  makeStateReflectable(state: {[p: string]: any}, source: any, root='') {\n    // console.log('root', root);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = source[key]\n      const pathKey = `${root ? `${root}.` : ''}${key}`;\n      const internalKey = this.getInternalKey(pathKey)\n      // console.log('internalKey', internalKey)\n      // if (DirtyableValue.isPrimitiveValue(val)) {\n      //   val = new DirtyableValue(val, internalKey);\n      // }\n      state[internalKey] = val; // new DirtyableValue(val, internalKey);\n      if (typeof val === 'function') {\n        continue\n      }\n\n      if (isReflectable(val)) {\n        self.makeStateReflectable(state, val, pathKey);\n        continue;\n      }\n      Object.defineProperty(source, key, {\n        get() { // ? 嵌套Object，应该从内部__state取还是外部source取？，内部外部取都会产生循环调用\n          console.log('[state] [GET]',internalKey, state[internalKey]);\n          return state[internalKey];\n        },\n\n        set(value) {\n          console.log('[state] [SET]', internalKey, value);\n          if (isReflectable(value)) {\n            self.makeStateReflectable(state, value, pathKey);\n            return\n          }\n          if (typeof value === 'function') {debugger\n            // self.__state[internalKey] = self.bindStateFunction(value)\n            value = bindFunctionScope(source ,value)\n          }\n          const beforeValue = state[internalKey];\n          if (beforeValue === value) {\n            return\n          }\n          state[internalKey] = value // new DirtyableValue(value, internalKey);\n\n          const nodes = self.varBindNodeObj[internalKey];\n          nodes && nodes.forEach((node: any, ref: WeakRef<any>) => {\n            console.log(999, node)\n            const actors = self.nodeActorsMap.get(node);\n            actors.forEach((act: CallableFunction) => {\n              console.log(998, act);\n              fastdom.mutate(() => {\n                act();\n              })\n            });\n          });\n        }\n      });\n    }\n  }\n\n  setState(source: any) {\n    this.sourceRef = source;\n    this.makeStateReflectable(this.__state, source);\n    this.render();\n  }\n  removeNode(node: VELEMENT) {\n    // const index = Array.from(node.parentNode.children).indexOf(node);\n    const next = node.nextSibling\n    const prev = node.previousSibling\n    this.nodePositionMap.set(node, {\n      parent: node.parentElement,\n      next,\n      prev\n    });\n    this.cacheIfTagDomFragment.appendChild(node);\n  }\n  restoreRemoveNode(node: VELEMENT) {\n    const info = this.nodePositionMap.get(node);\n    if (!info) {\n      return;\n    }\n    const {parent, next, prev} = info;\n    if (!next) {\n      parent.appendChild(node);\n      return\n    }\n    parent.insertBefore(node, next)\n  }\n\n\n\n\n\n  getNodeCompileScope(node: VELEMENT| Text): any {\n    const parent = node.parentNode;\n    const parentScope = this.compileContentNodeMap.get(parent);\n    const nodeScope = this.compileContentNodeMap.get(node);\n    return {...parentScope, ...nodeScope};\n\n    // let parent = node;\n    // let mergedScope = {}\n    // while ((parent as HTMLElement) != this) {\n    //   const scope = this.compileContentNodeMap.get(parent);\n    //   if (scope) {\n    //     mergedScope = {...scope, ...mergedScope}\n    //   }\n    //   parent = parent.parentElement as VELEMENT\n    // }\n    // return mergedScope\n  }\n  bindVarToNode(varName: string, node: VELEMENT) {\n    if (!this.varBindNodeObj[varName]) {\n      this.varBindNodeObj[varName] = new IterableWeakSet<VELEMENT>();\n    }\n    this.varBindNodeObj[varName].add(node)\n    if (!this.nodeBindVarObj.get(node)) {\n      this.nodeBindVarObj.set(node, new Set<string>())\n    }\n    this.nodeBindVarObj.get(node).add(varName)\n  }\n  bindNodePropAction(node: VELEMENT, attrName: string, attrValue: string) {\n    if (!node.parentElement) {\n      return\n    }\n    node.removeAttribute(attrName);\n\n    const lambdaFn = lambda(attrValue);\n\n    this.__state.startRecordExpressionVars()\n\n    const vars = this.__state.stopRecordExpressionVars();\n    vars.forEach((v: string) => {\n      if (!this.varExpressionObj[v]) {\n        this.varExpressionObj[v] = new Set<EXPRESSION_ACTION>();\n      }\n      this.varExpressionObj[v].add(node);\n    });\n    const action = ((attrNode: VELEMENT, fn: CallableFunction, actAttrName: string) => {\n      const scope = this.getNodeCompileScope(attrNode);\n      // const result = lambdaFn({...this.__state, ...scope});\n      // const result = lambdaFn( Object.assign(this.__state, scope));\n      const result = fn( this.__state, scope);\n      attrNode.setAttribute(actAttrName, result)\n    }).bind(null, node, lambdaFn, attrName.substring(1));\n    if (!this.expressionNodeMap.get(node)) {\n      this.expressionNodeMap.set(node, new Set())\n    }\n    this.expressionNodeMap.get(node).add(action)\n    action();\n  }\n\n\n\n\n  bindNodeExpression(node: VELEMENT, exp: VAR_AND_EXPRESSION, action: CallableFunction) {\n    let lambdaFn: CallableFunction = () => {}\n    if (exp.runtimeFn) {\n      lambdaFn = exp.runtimeFn\n    } else {\n      lambdaFn = lambda(exp.expression)\n    }\n\n\n    exp.vars.forEach((v: string) => {\n      if (!Object.prototype.hasOwnProperty.call(this.__state, v)) {\n        return;\n      }\n      if (typeof this.__state[v] == 'function') {\n        return\n      }\n      this.bindVarToNode(v, node)\n    });\n    const compileVar = () => {\n      if (!node.parentNode) {\n        return\n      }\n      const scope = this.getNodeCompileScope(node);\n      let result = null\n      if (exp.monitState) {\n        this.__state.startRecordExpressionVars();\n        result = lambdaFn(this.__state, scope);\n        const vars = this.__state.stopRecordExpressionVars();\n        vars.forEach((v: string) => {\n          this.bindVarToNode(v, node);\n        });\n      } else {\n        result = lambdaFn(this.__state, scope);\n      }\n\n      return result\n    }\n    const actor: ACTOR =  ((result :string) => {\n      if (!result) {\n        const scope = this.getNodeCompileScope(node);\n        // const fnStr = lambdaFn.toString().slice(275)\n        // console.log(fnStr)\n        result = lambdaFn( this.__state, scope)\n      }\n      action(result)\n      // node.textContent = result;\n    });\n\n    this.bindNodeActor(node, actor, compileVar);\n  }\n\n  bindNodeLoop(node: VELEMENT, loopVarName: string, bindVar: string, eachKey = '') {\n    const begin = document.createComment(`each ${bindVar} of ${loopVarName}`)\n    const end = document.createComment(`end each`)\n    node.parentNode.insertBefore(begin, node)\n    node.parentNode.insertBefore(end, node.nextSibling)\n\n    this.cacheLoopTagDomFragment.appendChild(node)\n    if (typeof this.__state[loopVarName] !== 'function') {\n\n      this.bindVarToNode(loopVarName, node)\n    }\n    const exp: VAR_AND_EXPRESSION = {\n      expression: `${loopVarName}`,\n      vars: [loopVarName],\n      // TODO loop 里的这个应该是返回操作,例如,del => 0,1 append 4, 5, and 2, 3 no change\n      // runtimeFn: () => {}\n    }\n    // const lambdaFn = lambda(exp.expression)\n    const patchItems = (old_blocks: any[], list: any[], keyName: string, bindVar:string) => {\n      // const nodeCompileContext = this.compileContentNodeMap.get(next);\n      // old_list.push(nodeCompileContext[bindVar].item)\n      let o = old_blocks.length;\n      let n = list.length;\n      const old_indexes:{[key: string]: any} = {}\n      let i = o;\n      const lookup = new Map()\n      while (i--) {\n        const nodeCompileContext = this.compileContentNodeMap.get(old_blocks[i]);\n        const k = nodeCompileContext[bindVar]['item'][keyName]\n        old_indexes[k] = i;\n        lookup.set(k, old_blocks[i])\n      }\n      console.log('old_indexes', old_indexes)\n\n      // const lookup = new Map()\n      // old_blocks.forEach(b => {\n      //   // lookup.set(b[key], new Node(b.key))\n      //   lookup.set(b[keyName], b)\n      // })\n\n      const new_blocks = [];\n      const new_lookup = new Map();\n      const deltas = new Map();\n      i = n\n      while (i--) {\n        const key = list[i][keyName];\n        let block = lookup.get(key);\n        // 这个block 应该对节点操作了?\n        if (!block) { // 新node, create it\n          // block = create_each_block(key, child_ctx);\n          // block.c();\n          // console.log('create', key);\n          block = node.cloneNode(true) as VELEMENT;\n          block.___uniqueItemKey = key;\n          block['detach'] = () => {\n            const varNames = this.nodeBindVarObj.get(block)\n            varNames.forEach(v => {\n              const iterSet = this.varBindNodeObj[v]\n              iterSet.forEach((el: any, ref: WeakRef<any>) => {\n                if (el === block) {\n                  iterSet.deleteByRef(ref)\n                }\n              })\n            })\n            this.nodeActorsMap.delete(block)\n          }\n          // block = new Node(key)\n        } else { // is old, only update it\n          // block.p(child_ctx, dirty);\n          // block.update(key)\n          console.log('update', key);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n          deltas.set(key, Math.abs(i - old_indexes[key]));\n      }\n      let next: any = end;\n      const will_move = new Set();\n      const did_move = new Set();\n\n      const destroy = (block: VELEMENT, lookup: Map<any, any>) => {\n        // const nodeCompileContext = this.compileContentNodeMap.get(block);\n        // const k = nodeCompileContext[bindVar]['item'][keyName]\n        console.log(this.varBindNodeObj)\n        lookup.delete(block.___uniqueItemKey);\n        block.remove()\n        block.detach()\n        console.log('destory', block, lookup )\n      }\n      const insert = (block: VELEMENT) => {\n\n        // console.log('insert', next? 'prev' : 'append', block)\n        lookup.set(block.___uniqueItemKey, block);\n        if (next) {\n          end.parentNode.insertBefore(block, next);\n        } else {\n          end.parentNode.appendChild(block);\n        }\n        const item = list[n-1]\n        const index = n;\n        const nodeCompileContext = this.compileContentNodeMap.get(block);\n        this.compileContentNodeMap.set(block, {\n          ...nodeCompileContext,\n          [bindVar]: {\n            item, index, key: block.___uniqueItemKey\n          },\n        });\n        compileWalker(block as VELEMENT, this.compile)\n        next = block;\n        n--;\n      }\n\n      while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.id;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n          next = new_block.first;\n          o--;\n          n--;\n        } else if (!new_lookup.has(old_key)) {\n          // remove old block\n          destroy(old_block, lookup);\n\n          o--;\n        } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n          insert(new_block);\n        } else if (did_move.has(old_key)) {\n          o--;\n        } else if (deltas.get(new_key) > deltas.get(old_key)) {\n          did_move.add(new_key);\n          insert(new_block);\n        } else {\n          will_move.add(old_key);\n          o--;\n        }\n      }\n      while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block[keyName])) {\n          destroy(old_block, lookup);\n\n        }\n      }\n      while (n) {\n        insert(new_blocks[n - 1]);\n      }\n      return new_blocks\n    }\n\n\n\n    this.bindNodeExpression(node, exp, (result: any) => {\n      let originResult = node.___bind_meta;console.log(exp)\n\n      if (!originResult||!Array.isArray(originResult)) {\n        originResult = [];\n      }\n      const old_list = [];\n      let start = begin.nextSibling;\n      while(start && start != end) {\n        const next = start.nextSibling;\n\n        // const nodeCompileContext = this.compileContentNodeMap.get(next);\n        // old_list.push(nodeCompileContext[bindVar].item)\n        old_list.push(start)\n        start = next;\n      }\n      patchItems(old_list, result, eachKey, bindVar);\n      node.___bind_meta = result;\n      return\n      // TODO use item key only change special changed item\n      start = begin.nextSibling;\n      // while(start && start != end) {\n      //   const next = start.nextSibling;\n      //   void (start as HTMLElement).remove();\n      //   start = next;\n      // }\n\n      (result as unknown as Array<any>).forEach((item: any, index: number) => {\n        const renderForNode = node.cloneNode(true) as VELEMENT;\n        this.gcRegistry.register(renderForNode, `renderForNode-${item.id}-${index}`);\n        const eachItemKey = eachKey? item[eachKey] : undefined;\n        if (eachItemKey && (start as VELEMENT).___uniqueItemKey === eachItemKey ) {\n          return\n        }\n        const nodeCompileContext = this.compileContentNodeMap.get(renderForNode);\n        renderForNode.___uniqueItemKey = eachKey? item[eachKey] : '';\n\n        this.compileContentNodeMap.set(renderForNode, {\n          ...nodeCompileContext,\n          [bindVar]: {\n            item, index, key: eachItemKey\n          },\n        });\n\n        if (start && start != end) {  // 有就替换\n          const next = start.nextSibling;\n          start.replaceWith(renderForNode)\n          start = next;\n        } else {  // 没有就插入\n          end.parentNode.insertBefore(renderForNode, end);\n        }\n        compileWalker(renderForNode as VELEMENT, this.compile)\n      });\n      while(start && start != end) { // 多余的删除\n        const next = start.nextSibling;\n        void (start as HTMLElement).remove();\n        start = next;\n      }\n    })\n    return\n\n\n\n\n\n\n\n  }\n\n  bindNodeProp(node: VELEMENT, propName: string, valueExp: string) {\n    const prop = propName.substring(1)\n    node.removeAttribute(propName);\n    node.addEventListener('input', (e) => {\n      // this.__state[valueExp] = node[prop]\n      const paths = valueExp.split('.')\n      let target = this.sourceRef;\n      const final = paths.pop();\n      while(paths.length) {\n        const p = paths.shift()\n        target = target[p]\n      }\n      const nodeType = node.type;\n      const asType = nodeType.charAt(0).toUpperCase() + nodeType.slice(1);\n      let valProp = `${prop}As${asType}`;\n      if(typeof node[valProp] == 'undefined') {\n        valProp = prop\n      }\n      target[final] = node[valProp]\n    });\n    this.bindNodeExpression(node, {\n      expression: valueExp,\n      vars: [valueExp]\n    }, (result: string) => {\n      // const asType = result.charAt(0).toUpperCase() + result.slice(1);\n      // if (prop == 'value') {\n      //   const testProp = `valueAs${asType}`;\n      // }\n      node[prop] = result\n    });\n  }\n\n\n\n\n  bindStateFunction(fn: () => void) {\n    return (function() {\n      return eval(fn.toString());\n    }).call(this.__state)\n  }\n  bindNodeActor(node: VELEMENT|Text, actor: ACTOR, compileVar: CallableFunction) {\n    if (!this.nodeActorsMap.get(node)) {\n      this.nodeActorsMap.set(node, new Set<ACTOR>())\n      // this.nodeActorsMap.set(node, new IterableWeakSet<ACTOR>())\n    }\n    this.gcRegistry.register(actor, \"gc actor fn\");\n    this.nodeActorsMap.get(node).add(actor);\n    fastdom.measure(() => {\n      const result = compileVar()\n      fastdom.mutate(() => {\n        actor(result);\n      })\n    })\n    // this.compileVarQueue.add(compileVar)\n    // if (!this.compileVarNodes.get(node)) {\n    //   this.compileVarNodes.set(node, new WeakSet())\n    // }\n    // this.compileVarNodes.get(node).add(compileVar)\n  }\n  expandShorthandAttributes(node: VELEMENT) {\n    const attrs = node.getAttributeNames();\n    for (let i = 0; i < attrs.length; i++) {\n      const attr = node.getAttributeNode(attrs[i])\n      let attrName = attr.name as unknown as string;\n      let attrValue = attr.value as unknown as string;\n      const isShorthand =  EXPRESSION_REGEX.exec(attrName)\n      EXPRESSION_REGEX.lastIndex = 0; // reset pos\n      if (isShorthand) {\n        node.removeAttribute(attrName);\n        attrName = isShorthand[1];\n        if (attrName.trim().startsWith('...')) {\n          const propsName = attrName.trim().replace('...', '');\n          const propsObj = this.sourceRef[propsName];\n          if (this.sourceRef[propsName]) {\n            const propsKeys =Object.keys(propsObj)\n            for (let j = 0; j < propsKeys.length; j++) {\n              const pk = propsKeys[j]\n              attrValue = `{${propsName}.${pk}}`\n              node.setAttribute(pk, attrValue)\n            }\n\n          }\n        } else {\n          attrValue = `{${attrName}}`\n          node.setAttribute(attrName, attrValue)\n        }\n\n      }\n    }\n  }\n  isTrigger(attrName: string) {\n    return attrName.startsWith('@')\n  }\n  compile = (node: VELEMENT): LOOP_CONDITION_STATEMENT => {\n    if (node.nodeName == 'SCRIPT') {\n      return;\n    }\n    if (node.nodeType === COMMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) { // comment & DOCUMENT_FRAGMENT_NODE\n      return ;\n    }\n\n    if (node.nodeType === TEXT_NODE) {\n      const txtNode = (node as unknown as Text);\n      if (txtNode.wholeText.trim()) {\n        const textNodes = [];\n        const expressionStr = txtNode.wholeText;\n        const vars = extractVarsV2(expressionStr);\n        if (vars.length) {\n          let s = 0;\n          while(vars.length) {\n            const {varName, expName, start, end} = vars.shift();\n            let t = expressionStr.substring(s, start);\n            console.log(expName, start, end);\n            const vv = extractVarsFromObject(this.__state, expName)\n            textNodes.push(document.createTextNode(t) );\n            t = expName\n            if (typeof this.__state[varName] === 'function') {\n              // const p1 = varName.indexOf('{')\n              // const p2 =varName.lastIndexOf('}')\n              // varName = varName.substring(p1 + 1, p2)\n              t = `{${varName}()}`\n            }\n            let tn: any = null;\n            let isHtmlNode = false;\n            if (expName.startsWith('{!')) {\n              isHtmlNode = true;\n              tn = document.createComment('')\n              const holderForReplace = document.createComment('')\n              textNodes.push(holderForReplace)\n              t = t.replace('{!', '{');\n            } else {\n              tn = document.createTextNode(t)\n            }\n\n            this.bindNodeExpression(tn as unknown as VELEMENT, {\n              expression: \"`$\" + t + \"`\",\n              vars:[varName, ...vv]\n            } , (result: any) => {\n              if (isHtmlNode) {\n                tn.previousSibling.replaceWith(document.createRange().createContextualFragment(result));\n              } else {\n                tn.textContent = result;\n              }\n            })\n            textNodes.push(tn)\n            s = end\n          }\n          if (s < expressionStr.length) {\n            const t = expressionStr.substring(s)\n            textNodes.push(document.createTextNode(t))\n          }\n          txtNode.replaceWith(...textNodes)\n        }\n\n      }\n      // text node stop here\n      return LOOP_CONDITION_STATEMENT.CONTINUE;\n    }\n\n    this.expandShorthandAttributes(node);\n    const attrs = node.getAttributeNames()\n    const eachVarName = attrs.find((attr) => {\n       return attr.startsWith(':each-')\n     });\n\n     const isLoopNode = Boolean(eachVarName);\n\n\n     if (isLoopNode) {\n       if (eachVarName.startsWith(':each-')) { // each expression\n         const keyAttr = node.getAttribute(':each-key')\n         if (!keyAttr) {\n           throw new Error('each expression need key')\n         }\n        node.removeAttribute(':each-key')\n\n         const attrValue = node.getAttribute(eachVarName)\n         // console.log('[each]', eachVarName, attrValue);\n         let loopVar = toCamel(eachVarName.replace(':each-', '')  )\n         let bindVar = attrValue\n         // const eachPlaceHolder = document.createComment(`each ${attrValue } of ${loopVar}`) as unknown as VELEMENT\n         // node.parentNode.insertBefore(eachPlaceHolder, node.nextSibling)\n         node.removeAttribute(eachVarName)\n         const loopItemVars = extractVarsV2(loopVar)\n         if (loopItemVars[0]) {\n           const { varName } = loopItemVars[0];\n           loopVar = varName\n           // console.log('[each] [loopVar]', loopVar)\n         }\n         const eachItemVars = extractVarsV2(attrValue)\n         if (eachItemVars[0]) {\n           const { varName } = eachItemVars[0];\n           bindVar = varName\n           // console.log('[each] [bindVar]', bindVar)\n         }\n         let loopExpression = loopVar;\n         if (typeof this.__state[loopVar] === 'function') { // 是方法的话应该按attribute原样显示\n           loopExpression = `${loopVar}()`\n         }\n         this.bindNodeLoop(node, loopVar, bindVar, keyAttr);\n         return LOOP_CONDITION_STATEMENT.CONTINUE;\n       }\n\n     }\n\n    // console.log('attrs', node, attrs);\n    for (let i = 0; i < attrs.length; i++) {\n      const attr = node.getAttributeNode(attrs[i])\n      const attrName = attr.name as unknown as string;\n      const attrValue = attr.value as unknown as string;\n\n      if (attrName.startsWith(':if-')) { // if expression\n        // console.log('[if]', attrName, attrValue);\n        const ifPlaceHolder = document.createComment(`if ${attrName}==${attrValue}`) as unknown as VELEMENT\n        // node.parentNode.insertBefore(ifPlaceHolder, node)\n        node.parentNode.insertBefore(ifPlaceHolder, node.nextSibling)\n        node.removeAttribute(attrName)\n        const vars = extractVarsV2(attrValue)\n        if (vars[0]) { // should only one\n          let { varName } = vars[0];\n          let vv: string[] = [];\n          if (typeof this.__state[varName] === 'function') {\n            varName = `${varName}()`\n          } else {\n            vv = extractVarsFromObject(this.__state, varName)\n          }\n          const conditionExpr = `${attrName.substring(4)} === ${varName}`\n\n          this.bindNodeExpression(node as unknown as VELEMENT, {\n            expression: conditionExpr,\n            vars: vv\n          } , (result: any) => {\n            if (!result) {\n              this.removeNode(node);\n            } else {\n              this.restoreRemoveNode(node);\n            }\n          })\n        }\n        continue\n      }\n\n      if (attrName.startsWith('.')) {\n        console.log('[prop]', attrName, attrValue);\n        const vars = extractVarsV2(attrValue)\n        if (vars[0]) { // should only one\n          this.bindNodeProp(node, attrName, vars[0].varName );\n        }\n        continue\n      }\n\n\n      const attrVars = this.isTrigger(attrName) ? [] : extractVarsV2(attrValue);\n      if (attrVars.length) {\n        const vars: string[] = [];\n        // console.log('attrValue', attrValue)\n        let attrStr = attrValue;\n        attrVars.forEach((v) => {\n          // console.log(v)\n          let varName = v.expName;\n          vars.push(v.varName)\n          const attrVar = this.__state[v.varName]\n          if (typeof attrVar === 'function' || typeof attrVar === 'undefined') {\n            // varName = `{${v.varName}()}` // 属性内方法不执行了\n            varName = `{'${v.varName}'}` // 方法名\n          }\n          const re = new RegExp(v.expName, 'g')\n          attrStr = attrStr.replace(re, \"$\" + varName + \"\");\n          // attrStr = attrStr.replaceAll(v.expName, \"$\" + varName + \"\");\n        })\n        // console.log(attrStr)\n        this.bindNodeExpression(node as unknown as VELEMENT, {\n          expression: \"`\" + attrStr + \"`\",\n          vars\n        }, (result: any) => {\n          // console.log(node, attrName, result)\n          node.setAttribute(attrName, result);\n        });\n      }\n\n      if (attrName.startsWith('@')) {\n        node.removeAttribute(attrName)\n        const eventName = attrName.substring(1);\n        console.log('[event]', attrName, attrValue);\n        const callbacks = extractVarsV2(attrValue);\n        let callback = attrValue;\n        if (callbacks && callbacks.length) {\n          for (let j = 0; j < callbacks.length; j++) {\n            const cb = callbacks[j];\n            let cbName: any = cb;\n            if (cb && cb.varName) {\n              cbName = cb.varName\n            }\n            if (this.sourceRef[cbName] ) {\n              callback = cbName\n            }\n          }\n        }\n        console.log('callback', callback)\n        node.addEventListener(eventName, (evt) => {\n          // this.__state[attrValue](evt)\n          fastdom.mutate(() => {\n            this.sourceRef[callback](evt)\n          })\n        })\n      }\n    }\n  }\n\n\n\n\n  disconnectedCallback() {\n    // browser calls this method when the element is removed from the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  static get observedAttributes(): string[]  {\n    return [/* array of attribute names to monitor for changes */];\n  }\n\n  attributeChangedCallback(name: string, oldValue: string, newValue: string) {\n    // called when one of attributes listed above is modified\n  }\n\n  adoptedCallback() {\n    // called when the element is moved to a new document\n    // (happens in document.adoptNode, very rarely used)\n  }\n\n  // there can be other element methods and properties\n}\n\ncustomElements.define(\"ez-widget\", EzWidget);\n"],"names":["win","raf","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","FastDom","self","this","reads","writes","bind","scheduleFlush","fastdom","scheduled","flush","error","length","runTasks","e","message","remove","array","item","index","indexOf","splice","prototype","constructor","tasks","task","shift","measure","fn","ctx","push","mutate","clear","extend","props","Error","child","Object","create","target","source","key","hasOwnProperty","mixin","initialize","catch","exports","define","module","window","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","r","Symbol","toStringTag","defineProperty","value","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","COMMENT_NODE","randomLocalsScopeName","Date","now","IS_PROXY","PARENT_PATH","___IterableWeakSet","Set","add","el","ref","super","values","deref","WeakRef","forEach","delete","iterator","IterableWeakSet","__set","deleteByValue","deleteByRef","LOOP_CONDITION_STATEMENT","EXPRESSION_REGEX","DOM_RENDER_ACTION_TYPE","DirtyableValue","pathKey","_dirty","_pathKey","_value","static","includes","val","isDirty","reset","toString","valueOf","isReflectable","v","Array","isArray","toCamel","s","replace","$1","toUpperCase","___lambda","exp","node","Proxy","has","get","prop","receiver","console","log","Reflect","Function","call","lambda","cache","stylesheet","CSSStyleSheet","slice","treeWalker","compile","nodeType","curChild","firstChild","nextSibling","walk","nodes","check","normalize","ret","CONTINUE","BREAK","RETURN","childNodes","concat","compileWalker","watchDom","fragment","mutationRecords","observer","MutationObserver","mutationsList","observe","childList","subtree","attributes","attributeOldValue","characterDataOldValue","characterData","takeRecords","MutationRecord","disconnect","subStrAtPos","tpl","step","pos","f","i","join","extractVarsV2","template","openChar","closeChar","ol","cl","tl","data","sq","dq","substring","j","pop","start","end","expName","trim","varName","extractVarsFromObject","obj","str","ks","keys","filter","k","re","RegExp","match","bindFunctionScope","eval","StateHandle","p","recordExpressionVars","WeakSet","result","parent","String","set","newVal","StateProxy","deleteProperty","getOwnPropertyDescriptor","enumerable","configurable","writable","ownKeys","loopNestedObj","entries","EzWidget","HTMLElement","__state","varExpressionObj","expressionNodeMap","WeakMap","nodePositionMap","compileContentNodeMap","nodeActorsMap","varBindNodeObj","nodeBindVarObj","nodeName","txtNode","wholeText","textNodes","expressionStr","vars","t","vv","document","createTextNode","tn","isHtmlNode","startsWith","createComment","holderForReplace","bindNodeExpression","expression","previousSibling","replaceWith","createRange","createContextualFragment","textContent","expandShorthandAttributes","attrs","getAttributeNames","eachVarName","find","attr","Boolean","keyAttr","getAttribute","removeAttribute","attrValue","loopVar","bindVar","loopItemVars","eachItemVars","loopExpression","bindNodeLoop","getAttributeNode","attrName","name","ifPlaceHolder","parentNode","insertBefore","conditionExpr","restoreRemoveNode","removeNode","bindNodeProp","attrVars","isTrigger","attrStr","attrVar","setAttribute","eventName","callbacks","callback","cbName","sourceRef","addEventListener","evt","shadow","attachShadow","mode","adoptedStyleSheets","innerHTML","gcRegistry","FinalizationRegistry","heldValue","connectedCallback","cssRules","cacheIfTagDomFragment","createDocumentFragment","cacheLoopTagDomFragment","dispatchEvent","CustomEvent","bubbles","detail","render","getInternalKey","makeStateReflectable","state","root","internalKey","act","setState","next","prev","parentElement","appendChild","info","getNodeCompileScope","parentScope","nodeScope","bindVarToNode","bindNodePropAction","lambdaFn","startRecordExpressionVars","stopRecordExpressionVars","action","attrNode","actAttrName","scope","runtimeFn","bindNodeActor","monitState","loopVarName","eachKey","begin","patchItems","old_blocks","list","keyName","o","n","old_indexes","lookup","Map","new_blocks","new_lookup","deltas","block","cloneNode","___uniqueItemKey","iterSet","Math","abs","will_move","did_move","destroy","detach","insert","nodeCompileContext","new_block","old_block","new_key","id","old_key","first","originResult","___bind_meta","old_list","propName","valueExp","paths","split","final","type","asType","charAt","valProp","bindStateFunction","actor","compileVar","register","isShorthand","exec","lastIndex","propsName","propsObj","propsKeys","pk","disconnectedCallback","observedAttributes","attributeChangedCallback","oldValue","newValue","adoptedCallback","customElements"],"sourceRoot":""}